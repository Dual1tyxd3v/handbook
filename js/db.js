const data = {
  Git: [
    [
      `git diff`,
      `Показать изменения`
    ],
    [
      `git config --global x`,
      `Позволяет настроить хранилище Git после инициализации где х свойство и значение:<br>- user.name "name" - указать имя<br>- user.email "email" указать email<br>git config --list - получение всех комманд конфига`
    ],
    [
      `git log`,
      `Показать логи коммитов<hr>git log --online - показать логи в 1 строку`
    ],
    [
      `git reset`,
      `Отменяет все незафиксированные изменения из индексирования`
    ],
    [
      `git show *`,
      `Показать отдельный коммит где * - хэш`
    ],
    [
      `git branch`,
      `Показать все ветки<br>git branch -m old new - изменение имени ветки`
    ],
    [
      `git checkout`,
      `git checkout * - Откатить изменения где * - имя файла<hr>git checkout _hash _name - откатить файл к определенной сборке<hr>git checkout -b x - создать ветку с именем x<br>git checkout x - изменить ветку на x`
    ],
    [
      `git commit`,
      `Фиксирует изменения<hr>git commit --amend -m "New text" - изменить сообщение последнего коммита`
    ],
    [
      `git rm *`,
      `Удалить файл(*) из коммита<hr>git rm --cached * - удаляет файл из коммита а также из индексации`
    ],
    [
      `git clone *`,
      `Копирует репозиторий по адресу *`
    ]
  ],
  Npm: [

  ],
  Html: [
    [
      'Тег <span class="tag">&lt;div&gt;</span>',
      'В высоту занимает размер помещенного внутрь контента, а в ширину все свободное пространство.<hr>Является неинтерактивным элементом'
    ],
    [
      'Тег <span class="tag">&lt;small&gt;</span>',
      'Уменьшает размер шрифта контента внутри себя на условную 1. В HTML размер шрифта измеряется в условных единицах от 1 до 7, а по умолчанию средний текст = 3'
    ],
    [
      'Тег <span class="tag">&lt;canvas&gt;</span>',
      'Используется для вставки низкоуровневой графики'
    ],
    [
      'Типы списков',
      '1. ul - маркированный список<br>2. ol - нумерованный список<br>3. dl - список определений'
    ],
    [
      'Типы input',
      '1. text<br>2. password<br>3. submit<br>4. button<br>5. email<br>6. number<br>7. checkbox<br>8. date'
    ],
    [
      `Тег <span class="tag">&lt;meta</span>
      name="description" content="_descr_"<span class="tag">&gt;</span>`,
      'Тэг для описания сайта в поисковике, где _descr_ само описание'
    ],
    [
      `Валидация документа`,
      'Это проверка документа специальным валидатором W3C который сначала определяет тип документа а потом html на ошибки. 4 типа ошибки:<br>1. синтаксические<br>2. вложенность<br>3. document type definition - схема документа<br>4. наличие посторонних элементов'
    ],
    [
      `Doctype`,
      'Предназначен для указания браузеру типа документа чтобы он смог правильно распарсить его'
    ],
    [
      `Атрибут tabindex`,
      `Позволяет делать элемент интерактивным(только при положительном значении) (tabindex="1")`
    ],
    [
      `Атрибут aria-label`,
      `Позволяет добавить описание элементу если у оно у него отсутствует`
    ],
    [
      `Тег <span class="tag">&lt;label&gt;</span>`,
      `Использувется для скринридеров с привязкой к полю input<br>1 вариант использования<pre>
&lt;label for="id"&gt;Some text&lt;/label&gt;
&lt;input id="id"&gt;</pre>2 вариант<pre>
&lt;label&gt;
  &lt;input&gt;
  some text...  
&lt;/label&gt;</pre>`
    ],
    [
      `Тэг <span class="tag">&lt;a&gt;</span>`,
      `Имеет прозрачную модель содержимого. Это значит что сам тэг не ставит условия по содержимому, а это делает его родитель`
    ],
    [
      `Тэг <span class="tag">&lt;sup&gt;</span>`,
      `Тэг для отображения текста в виде верхнего индекса`
    ],
    [
      `Тэг <span class="tag">&lt;sub&gt;</span>`,
      `Тэг для отображения текста в виде нижнего индекса`
    ],
    [
      `Тэг <span class="tag">&lt;datalist&gt;</span>`,
      `Тэг для отображения выпадающего списка<pre>
&lt;input list="ice-cream-flavors" id="ice-cream-choice" name="ice-cream-choice"&gt;
&lt;datalist id="ice-cream-flavors"&gt;
    &lt;option value="Chocolate"&gt;
    &lt;option value="Coconut"&gt;
    &lt;option value="Mint"&gt;
    &lt;option value="Strawberry"&gt;
    &lt;option value="Vanilla"&gt;
&lt;/datalist&gt;</pre>`
    ],
    [
      `Тэг <span class="tag">&lt;script&gt;</span>`,
      `Подключает скрипты на страницу. Имеет несколько атрибутов -<br>1) async - асинхронное подключение<br>2) defer - ждет отрисовки страницы`
    ],
    [
      `Тэг <span class="tag">&lt;time&gt;</span>`,
      `Отображает дату/время в машиночитаемом формате. Предназначен для скринридеров + помогает при добавлении событий в календарь`
    ],
    [
      'Favicon',
      `иконка для сайта 512х512.<br>
      favicon-generator.org - сайт для создания иконок`
    ],
    [
      'Строчные теги',
      `Распологаются рядом пока хватает места.
      <hr>
      Являются контентом (&lt;a&gt;, &lt;img&gt;).
      <hr>
      В строчные теги можно положить только строчные.
      <hr>
      Нельзя применить вертикальные отступы и ширину (display: inline)`
    ],
    [
     'Блочные теги',
      `Занимают всю ширину, являются каркасом страницы (display: block).
      <hr>
      Всегда начинаются с новой строки.`
    ],
    [
      'Progressive enhancement',
       `Разработка от простого к сложному`
    ],
    [
      'Graceful degradation',
       `Разработка от сложного к простому (desktop => mobile)`
    ],
    [
      `Тег <span class="tag">&lt;img&gt;</span>`,
      `Используется только для контента (ссылки, логотипы, иконки).<hr>Для ограничения размеров картинки по размеру блока используется глобальный стить - max-width: 100%`
    ]
  ],
  Css: [
    [
      `text-align`,
      `Выравнивает содержимое внутри контейнера по горизонтали(устаревший метод)`
    ],
    [
      `Вендорные префиксы`,
      `Специальная приставка для свойств которые не внедренны в браузер (-moz-opacity)`
    ],
    [
      `Блочная модель элемента`,
      `Правила по которым браузер определяет размеры элемента. Внешний отстут, рамка, внутренний отступ, размер контента.`
    ],
    [
      `Специфичность селекторов`,
      `Это градация приоритета стилей элемента<br>1. inline - 1000<br>2. id - 100<br>3. class/attr/: - 10<br>4. элемент/:: - 1`
    ],
    [
      `Варианты добавления CSS на сайт`,
      `1. Инлайн стили внутри самого тега (style, переопределение такого стиля возможно только с использованием !important)<br>2. Глобальные стили внутри тега head через тег &lt;style&gt;<br>3. Внешний файл стилей через link<br>4. Импорт внутри файла стилей`
    ],
    [
      `display: flex`,
      `justify-content: * - выравнивание элементов по горизонтали если направление по оси Х или по вертикали если Y.
      <hr>
      align-item: * - выравнивание по вертикали если направление по Х и по горизонтали если по Y.
      <hr>
      * - <br>
      flex-start - по левой/верхней стороне<br>
      flex-end -  по правой/нижней стороне<br>
      center - по центру<br>
      space-between - создает одинаковые отступы между элементами<br>
      space-around - делает отступы вокруг элементов из свободного пространства(по бокам выходит меньше потому что равны 0.5 от межблочных отступов)<br>
      space-evenly - распределяет свободное пространство для отступов вокруг элементов по ровну<br>
      stretch - растягивает элементы
      <hr>
      flex-direction - направление расположения элементов<br>
      row - справа налево (по default)<br>
      row-reverse - слева направо<br>
      column - сверху вниз<br>
      column-reverse - снизу вверх
      <hr>
      order - задает порядок элементов. По default = 0, 1 - сдвигает вправо, -1 влево.
      <hr>
      align-self - задает положение только для 1 элемента
      <hr>
      flex-wrap - обертка где:<br>
      nowrap - размеры элементов автоматически подгоняются для установки в 1 ряд<br>
      wrap - переносит элементы что не влезли<br>
      wrap-reverse - перенос с реверсом
      <hr>
      flex-flow - объединяет direction и wrap в 1 свойстве (flex-flow: column wrap)
      <hr>
      align-content - распределяет свободное пространство между и вокруг флекс элементов по оси Y`
    ],
    [
      `margin`,
      `Если у 2 элементов имеются отступы направленые друг к другу, то выберется тот что больше. Это называется
      схлопыванием.
      <hr>
      Обычно задается справа налево или сверхну вниз. Связано с тем что принято что блок не может двигать сам
      себя, а его двигает сосед (*-bottom, *-right).
      <hr>
      : 0 auto - выравнивание блока по горизонтали если задана ширина.`
    ],
    [
      `Единицы изменения`,
      `em - единица измерения на основе font-size. (1em = font-size). Подходит для позиционирования.
      <hr>
      rem - единица всегда равна 16px
      <hr>
      vh - равна высоте размера экрана
      <hr>
      vw - равна ширине размера экрана + скроллбар`
    ],
    [
      `box-shadow`,
      `задает тень блоку.<br>
      : 0px 4px 4px rgba(0, 0, 0, 0.25) - где 1 отклонение по Х относительно блока, 2 по Y, 3 радиус размытия, 4 цвет.`
    ],
    [
      `transform`,
      `translateY(*px) - сдвигает элемент на * пикселей по вертикали.<br>
      translateX(*px) - сдвигает по горизонтали<br>
      translate(*px, *px) - комбинированная запись где 1 по Х 2 по Y`
    ],
    [
      `transition`,
      `задает скорость анимации и свойство к которому оно применяется<br>
      : 1s all - 1 секунда для всех свойств`
    ],
    [
      `object-fit`,
      `указывает для &lt;img&gt; и &lt;video&gt; как контент должен заполнятся относительно высоты и ширины`
    ],
    [
      `white-space`,
      `форматирование текста. По default normal(обрезает пробелы и отступы).<br>
      : pre - оставляет текст в оригинальном форматировании`
    ],
    [
      `padding`,
      `Устанавливает отступы внутри элемента.
      <hr>
      Если у элемента нет соседей сверху и слева, то для того чтобы его пододвинуть родительскому контейнеру
      задается отступ (*-left, *-top).`
    ],
    [
      `z-index`,
      `Позиционирует элемент относительно оси z. По дефолту - 0. Работает только с absolute/relative.`
    ],
    [
      `border-box`,
      `box-sizing - при использовании отступов или border размер элемента не изменяется.`
    ],
    [
      `border-collapse`,
      `Указывает как отображать рамки соседних элементов<br>collapse - рамки будут схлопнуты как если бы это была цельная таблица<br>separate - у каждого элемента будет рамка и между ними будут отступы заданные border-spacing`
    ],
    [
      `@font-face`,
      `Подключение сторонего шрифта:<br>
      font-family: 'имя' - имя шрифта<br>
      src: local('имя') - сначала ищет на локальной машине<br>
      src: url(путь) - если на локальной не найдено то берет с Url.<br>
      font-display: swap - указывает что шрифт грузится асинхронно и пока он не подгружен будет применен стандартный шрифт<br>`
    ],
    [
      `Семантические теги`,
      `предназначены для поисковиков и скринридеров`
    ],
    [
      `БЭМ`,
      `блок + модель + модификатор - позволяет создавать блоки для дальнейшего переиспользования.
      <br>
      блокам не задают отступы
      <br>
      элемент - составная часть блока (class="блок-1__имя-элемента"). Элемент всегда часть блока а не другого элемента.
      <br>
      Модификатор - изменяет состояние элемента (class="блок__элемент-модификатор")`
    ],
    [
      `Шрифты`,
      `с засечками - serif, без засечек sans-serif`
    ],
    [
      `:nth-child(2n)`,
      `Псевдокласс позволяет задать свойста для каждого 2 элемента`
    ],
    [
      `position`,
      `relative - позволяет позиционировать относительно своего места при этом не выбивается из общего потока
      тегов.
      <hr>
      absolute - позиционируется от body если родителю не задан relative. При этом превращает элемент в
      строчный и выбивается из общего потока тегов.
      <hr>
      fixed - фиксирует элемент в заданном месте при прокрутке. Превращает в строчный элемент.
      <hr>
      sticky - когда страница прокручивается до такого элемента он становится fixed.`
    ],
    [
      `background-...`,
      `repeat - Повторять или нет изображение в элементе.
      <hr>
      position - позиция фонового изображения. Указывается словестно или в px, где 1 значение left, 2 top.
      <hr>
      size - contain/cover, где 1 увеличивается пока не упрется в высоту, а 2 заполняет во всю ширину но
      обрезается по высоте.
      <hr>
      attachment - поведение при прокрутке страницы
      <hr>
      background: url(...) .. center/size - сокращенная запись где позиция и размер указываются через /.
      <hr>
      linear-gradient(угол, цвет1 %перехода, цвет2 %перехода) - линейный градиент где %перехода обозначает
      место в котором 1 цвет переходит во 2.`
    ],
    [
      `list-style-type`,
      `Установка маркеров для списков (&lt;ol&gt;, &lt;ul&gt;), где none - отключает маркеры.`
    ],
    [
      `linear-gradiend()`,
      `Ф-ция для установки линейного градиента.<br>linear-gradient(x, #000 25%, #666 25% 50%, #fff 75%) - где<br>--1 цвет имеет конечную точку(там где начинается переход во 2)<br>--2 цвет имеет начальную точку там же где и конечная у 1 цвета и поэтому плавного перехода не будет. А также имеет конечную точку на 50% что означает там начнется переход в 3 цвет<br>--3 цвет поскольку является последним то имеет начальную точку в которой заканчивается последний переход.<br>x - это необязательный параметр указывающий направление градиента. По умолчанию он направлен сверху вниз. Может быть:<br>1) xdeg - указан в углах<br>2) xturn - указан в частях от единицы, где 0.25 = 90deg<br>3) to top left - может быть указан явно а также скомбинирован из нескольких направлений`
    ]
  ],
  Javascript: [
    [
      `.focus()`,
      `Метод элемента который устанавливает фокус на этом элементе`
    ],
    [
      `.isNaN(x)`,
      `Метод объекта Number для проверки переменной x на значение NaN. По скольку NaN ничему не равно даже самому себе то это единственная проверка`
    ],
    [
      `BigInt`,
      `Это строкове представление числа а потому математические операции проводить с ним нельзя. Единственное можно проводить не строгое сравнение с другими числами`
    ],
    [
      `!Числа с плавающей точкой`,
      `<pre>
const a = .3 - .2;
const b = .2 - .1;
console.log(a === b);</pre>Результатом этого сравнения будет false т.к. такие числа имеют не точности и для подобного сравнения сначала нужно преобразовать их в целые числа`
    ],
    [
      `.toString(x?)`,
      `Метод преобразовывает субъект на которомы был вызван в строку. Необязательный параметр указывает на систему исчислений`
    ],
    [
      `.toFixed(x)`,
      `Преобразует число в строкус х кол-вом символов после .(заполняет 0)`
    ],
    [
      `.toExponential(x)`,
      `Преобразует число в строкус х кол-вом символов после . применяя экспоненциальную запись (5.425e + 6)`
    ],
    [
      `var`,
      `Переменные объявленные с помощью var будут автоматические записаны в глобальный объект а потому их можно будет использовать в любой части кода. Если обращение к пемеренной идет до ее объявления то ее значением будет undefined`
    ],
    [
      `Математические операнды`,
      `<b>x**2**3</b> - операнд возведения в степень. Приоритет такого операнда выше чем у +/- и читается такое выражение справа налево => x**8<hr>
      <b>1 + 1 + 'a'</b> - операнд сложения, читается слева направо => 2a<br>
      <b>--/++</b> - инкремент и декремент сначала пытаются преобразовать переменную в число и лишь потом произвести операцию`
    ],
    [
      `instanceOf`,
      `Позволяет узнать принадлежит ли объект слева к экземпляру класса справа<hr>
      <b>a instanceOf b</b> - сначала вычисляется прототип b (b.prototype), затем если найдено происходит его поиск в списке прототипов a. Если слева не объект вернет false, если справа не экземпляр класса вернет TypeError`
    ],
    [
      `in`,
      `<b>console.log(('x' in someObject));</b> - оператор позволяет узнать есть ли указанное свойство в объекте. Возвращает boolean<br>
      <b>'toString' in someObj => true</b> - потому что у любого объекта есть метод toString<br>
      <b>'0' in [1,2,3] => true</b> - т.к. массив тот же объект и у него есть свойств 0 где находится первый элемент`
    ],
    [
      `Операция присваивания (=)`,
      `<b>const a = b = c = 4;</b> - при присваивании интепритация идет справа налево`
    ],
    [
      `WeakMap`,
      `Аналог множества Map который позволяет сборщику мусора освобождать память более эффективно из-за того что ключами в таком множестве могут быть только объекты а не примитивы. В связи с этим он не имеет размер и не является итерируемым а потому не может использовать стандартные методы массива`
    ],
    [
      `Классы`,
      `Классы в JS по сути просто набор объектов<pre>
class Some {    <sup>1</sup>
  
}

const A = class {     <sup>2</sup>
  
}</pre>Классы объявляются 2 методами. Class declaration и class expression<pre>
class My {
  static log() {
    console.log('hello');
  }
}
My.log();</pre>
Статические св-ва и методы класса(static) вызываются не на экземпляре а на прямую на конструкторе. Статические методы и поля определяются вне конструктора<pre>
class My {
  #value = 0; 
}</pre>Приватные поля класса не могут быть прочитаны или изменены извне<hr>
При наследовании класса, в конструкторе сначала должен быть описан вызов super()до использования this. Если подкласс не имеет своего конструктора то он создается неявно и в нем вызывается метод super() родителя`
    ],
    [
      `arguments`,
      `<pre>
function someF() {
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  } 
}</pre>В старых версиях JS использовалось свойство arguments которое ссылается на массив переданных в ф-цию аргументов`
    ],
    [
      `Дескрипторы`,
      `Позволяют более тонко настраивать отдельные св-ва объекта<pre>
const obj1 = {};
obj1.name = 'Bob';
Object.defineProperty(obj1, 'name1', { value: 'Bob', configurable: true, writable: true, enumerable: true });</pre>Обе записи создают идентичные св-ва. Чтобы использовать дескриптор используется метод defineProperty где в качестве 3 аргумента передается сам дескриптор с нужными параметрами св-ва<pre>
Object.defineProperties(obj1, {
  name3: {
    value: 'Bob'
  },
  name4: {
    value: 'Bob',
    writable: false
  }
});</pre>Также можно указать сразу несколько свойств с помощью defineProperties.В качестве 1 аргумента принимает сам объект а 2 аргумент объект содержащий имена добавляемых свойств которые содержат настройки. Если не указывать параметры св-ва то они будут установленны по умолчанию в true<hr>
Правила изменения объектов и свойств:<br>
1) если объект не расширяемый то можно только редактировать его св-ва<br>
2) если св-во не конфигурируемое то нельзя изменять его атрибуты configurable и enumerable а также изменять значение св-ва и его get/set. Также нельзя изменить св-во writable на true, только false<hr>
<b>Object.getOwnPropertyDescriptor(x, y)</b> - позволяет получить дескриптор свойста у в объекте х`
    ],
    [
      `Promise`,
      `Это объект который хранит состояние который используется для асинхронных действиий. Если асинхронное действие разрешится то состояние будет fullfiled(тогда вернет полученный результат), если же нет то rejected(тогда вернет причину ошибки).<pre>
const myProm = new Promise((res, rej) => {
  setTimeout(() => {
    res('hello world');
  }, 1000);
});

myProm.then((resp) => console.log(resp););</pre>Простой пример создания и использования Promise<hr>
Методы объекта Promise:<br>
<b>Promise.all(x)</b> - предназначен для выполнения сразу нескольких async ф-ций. В качестве аргумента принимает массив промисов и возвращает объект promise. Если хоть 1 промис будет отклонен то и конечный объект будет со статусом rejected. В противном случае вернет массив с полученными значениями каждого promise.<br>
<b>Promise.allSettled(x)</b> - аналог выше, но в любом случае возвращает массив объектов, где объект представляет каждый промис массива. Этот объект имеет 3 свойства:<br>
<b>-- .status</b> - статус выполнения промиса<br>
<b>-- .value</b> - какое то значение если промис был разрешен<br>
<b>-- .reason</b> - причина если промис был отклонен<br>
<b>Promise.race(x)</b> - тоже что и all но race дожидается лишь выполнения 1 промиса из массива после чего возвращает его результат<hr>
Чтобы использовать полученное значение или причину ошибки используется синтаксис await который может применятся только в async ф-циях`
    ],
    [
      `Функции генераторы`,
      `<pre>
function* gen(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
  yield 'text';
}
const useGen = gen(5);
useGen().next(); // 6
useGen().next(); // 7
useGen().next(); // 8
useGen().next(); // 'text'</pre>Это такая ф-ция которая позволяет выйти и войти обратно при этом весь контекст сохраняется при каждом входе. При выполнении тело ф-ции выполняется не сразу. Ф-ция возвращает объект итератор с методом next(). При вызове этого метода выполняется тело генератора до оператора yield который в свою очередь либо вернет значение либо делигирует другой ф-ции генератору. Метод next() возвращает объект с полями value и done. При передаче методу next аргумента генератор прекращает свою работу и вместо значения которое должен передать yield вернет переданный аргумент<pre>
function* gen2() {
  yield 2;
  yield 3;
}

function* gen1() {
  yield 1;
  yield* gen2();
  yeild 4;
}
const useGen = gen1();
useGen().next();  //1
useGen().next();  //2
useGen().next();  //3
useGen().next();  //4</pre>yield* позволяет делигировать выполнение другой ф-ции генератору<hr>
В случае если в генераторе значение возвращается с помощью return, то как только очередь дойдет до него все последующие вызовы прекратятся а метод next вернет объект с значением из return и done = true`
    ],
    [
      `Итерируемый объект`,
      `Это любой объект который имеет специальный итераторный метод который возвращает объект итератора. Сам итератор это объект с методом next() который возвращает результат итерации. Объект результата содержит свойста value и done. При итерации сначала вызывается итераторный метод. Затем на полученном итераторе многократно вызывается метод next пока значением свойста done результирующего объекта не будет true. Итерируемый метод имеет имя - <b>Symbol.iterator</b><pre>
class MyIterationObject {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
  [Symbol.iterator]() {
    let next = Math.ceil(this.from);
    let last = this.to;
    return {
      next() {
        return (next <= last) ? { value: next++ } : { done: true };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
}</pre>Реализация своего итерируемого объекта`
    ],
    [
      `URL`,
      `Объект для работы с URL. Имеет следующие свойства:<br>
      <b>.href</b> - полный адрес<br>
      <b>.origin</b> - полный домен<br>
      <b>.protocol</b> - http/https<br>
      <b>.host</b> - хост адреса с портом<br>
      <b>.hostname</b> - хост без порта<br>
      <b>.port</b> - порт<br>
      <b>.pathname</b> - путь между /.../ после хоста<br>
      <b>.search</b> - полный набор поисковых параметров (&q=)<br>
      <b>.hash</b> - все что после #<br>
      <b>.searchParams</b> - по сути является коллекцией(Set) поисковых параметров. Позволяет добавлять удалять и изменять элементы. При изменении автоматические обновляет поле search`
    ],
    [
      `Контекст`,
      `По сути контекст это внешняя область видимости. У каждой ф-ции свой контекст. Объект this является ссылкой на внешнюю область видимости или контекст. Контекст может менятся взависимости от того как была объявлена ф-ция или как она вызвана:<br>
      1) у стрелочных ф-ций контекстом будет являться область видимости в которой они были определены<br>
      2) если ф-ция объявленная декларативно то ее объект this будет ссылаться на глобальную область видимости (window) в нестрогом режиме или undefined в строгом<br>
      3) если ф-ция была вызвана как метод какого то объекта то объект this будет ссылаться на этот объект<pre>
const o = {
  someFunc() {
    return this;
  }
};
const a = o.someFunc;
a();</pre>
      4) если метод объекта был присвоен отдельной переменной, то при ее вызове контекст будет потерян<br>
      5) для простых декларативных ф-ций мы можем указать явно или привязать контекст с помощью методов apply, call и bind`
    ],
    [
      `Преобразование типов`,
      `<pre>
<b>Значение     toString        parseInt/Number bool</b>
undefined       'undefined'     NaN             false
null            'null'          0               false
true            'true'          1               true
false           'false'         0               false
''              ''              NaN             false
'1.2'           '1.2'           1.2             true
'one'           'one'           NaN             true
0               '0'             0               false
-0              '-0'            0               false
1               '1'             1               true
Infinity        'Infinity'      Infinity        true
-Infinity       '-Infinity'     -Infinity       true
NaN             'NaN'           NaN             false
{}              'ObjectObject'  NaN             true
[]              ''              NaN/0           true
[9]             '9'             9               true
['a']           'a'             NaN             true</pre>
<b>Boolean(), Number(), String()</b> явное преобразование<hr>
<b>3 + '' => string</b><br>
<b>+'4' => number</b> неявное преобразование<br>
<b>'4' - 0 => number</b><br>
<b>!!'' => false</b><br>
<b>n..toString()</b> - для преобразования числа в строку ставят 2 точки потому что интерпритатор ожидает сначала увидеть число в виде n.m а потом уже видит метод<br>
При преобразовании объекта сначала:<br>
1) приоритет у преобразования в строку<br>
2) приоритет у преобразования в число<br>
3) собственное преобразование<br>
При операциях с объектом сначала ищется метод valueOf, если он не найден тогда вызывается toString
Также все объекты всегда == true<hr>
Порядок преобразования при сравнении с < > => =<<br>
1) если есть объект то сначала интепритатор пытается получить его valueOf а потом toString<br>
2) если оба значения строки то они сравниваются в порядке определенным числовым порядком 16 битных значений Unicode (при сравнении строк заглавные буквы всегда > обычных)<br>
3) если хоть 1 значение не строка и не объект то оба преобразуются в число<br>
4) если хоть 1 значение NaN то всегда возвращается false`
    ],
    [
      `Встроенные методы строки`,
      `Строки в JS являются иммутабельными поэтому все методы возвращают новые строки<hr>
      <b>.substring(x, y)</b> - возвращает обрезанную строку с x + 1 до y индекса включительно<br>
      <b>.slice(x, y)</b> - тоже что и выше<br>
      <b>.indexOf(x, y?)</b> - возвращает индекс первого найденного символа х. y необязательный 2 параметр который указывает с какого индекса начинать поиск. Если позиция не найдена вернет -1<br>
      <b>.lastIndexOf(x)</b> - возвращает индекс последнего вхождения символа<br>
      <b>.startWith(x)</b> - проверяет начинается ли строка с переданного в нее аргумента и возвращает boolean<br>
      <b>.endWith(x)</b> - тоже что и выше только проверяет конец строки<br>
      <b>.includes(x)</b> - проверяет наличие в строке переданного аргумента<br>
      <b>.normalize()</b> - нормализация Unicode<br>
      <b>.charAt(x)</b> - выводит символ в строке под индексом x<br>
      <b>.charCodeAt(x)</b> - вернет 16 битное число символа в строке под индексом x<br>
      <b>.padStart(x, y?)</b> - заполняет строку символами у(если не передан то пробелами) в начале пока длина строки не станет равна х<br>
      <b>.padEnd(x, y?)</b> - тоже что и выше только заполняет с конца<br>
      <b>.trim()</b><br>
      <b>.trimEnd()</b> - удаляет пробелы в строке - везде/в конце/ в начале<br>
      <b>.trimStart()</b><br>
      <b>.repeat(x)</b> - возвращает исходную строку повторенную х раз<br>
      <b>.search(x)</b> - выдает позицию первого совпадения в строке переданного значения х (строка или регулярное выражение + не работает с флагом g)<br>
      <b>.match(x)</b> - вернет массив всех совпадений в строке. 1 элемент массива будет полученное совпадение, последующие элементы будут совпадениями найденные по группам если такие были - (). При неглобальном поиске также имеет ряд свойств:<br>
      <b> .input</b> - входная строка<br>
      <b> .index</b> - индекс позиции совпадения<br>
      <b> .groups</b> - если использовались именнованные группы они будут содержаться в этом объекте в виде - [имя_группы]: найденное_совпадение<br>
      <b>.matchAll()</b> - тоже что выше только с флагом g<hr>
      Регулярные выражения также содержат несколько свойств:<br>
      <b>.source</b> - строка с исходным выражением(readonly)<br>
      <b>.flags</b> - строка с флагами<br>
      <b>.global</b> - возвращает boolean задан ли флаг g<br>
      <b>.multiline</b> - boolean задан ли флаг m<br>
      <b>.ignoreCase</b> - boolean задан ли флаг i<br>
      <b>.dotAll</b> - boolean задан ли флаг s<br>
      <b>.unicode</b> - boolean задан ли флаг u<br>
      <b>.sticky</b> - boolean задан ли флаг y<br>
      <b>.test(x)</b> - boolean проверяет содержит ли строка х выражение`
    ],
    [
      `Встроенные математические методы`,
      `<b>.pow(a, b)</b> - возводит числоа а в степень b<br>
      <b>.round(a)</b> - округление до ближайшего целого<br>
      <b>.ceil(a)</b> - округление в большую сторону до целого<br>
      <b>.floor(a)</b> - округление в меньшую сторону до целого<br>
      <b>.abs(a)</b> - модуль числа a<br>
      <b>.sqrt(a)</b> - квадратный корень числа a (a в степени 0.5)<br>
      <b>.trunc(a)</b> - преобразует в целое число отбрасывая дробную часть (4.5 => 4)`
    ],
    [
      `window.location`,
      `Объект возвращающий текущую ссылку. Имеет следующие свойства:<br>
      <b>.href</b> - полная текущая ссылка<br>
      <b>.protocol</b> - протокол адреса (http/https)<br>
      <b>.host</b> - домен сайта<br>
      <b>.port</b> - порт<br>
      <b>.pathname</b> - путь к ресурсу (.../path/)<br>
      <b>.search</b> - параметры после ?key=value<br>
      <b>.hash</b> - все что после #`
    ],
    [
      `Наследование классов`,
      `<pre>
class Some {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  } 
}
class Another extends Some {
  constructor(a, b, c) {
    super(a, b);
    this.c = c;
  } 
}</pre>При наследовании другого класса в конструкторе сначала вызывают конструктор родителя с помощью super()`
    ],
    [
      `.filter()`,
      `Метод массива возвращающий новый массив после отфильтровывания на основе заданных условий в полученной callback ф-ции в виде аргумента.<hr>ar.filter(it => it); - вернет новый массив но уже без пустых ячеек т.к. вовзращает только те что подходят под условие, в данном случае true`
    ],
    [
      `Что такое DOM`,
      `Объектная модель документа представляющая интерфейс позволяющий взаимодействовать с разметкой страницы`
    ],
    [
      `.hasOwnProperty(х)`,
      `Метод объекта позволяющий искать свойство с именем х среди ТОЛЬКО собственных свойств объекта`
    ],
    [
      `.propertyIsEnumerable(x)`,
      `Метод объекта позволяющий искать свойство с именем х среди ТОЛЬКО собственных свойств объекта а также проверяет участвует ли оно в переборах`
    ],
    [
      `Object.getOwnPropertyNames(x)`,
      `Метод возвращающий массив из имен свойст объекта х которые являются Symbol`
    ],
    [
      `Object.getOwnPropertySymbols(x)`,
      `Метод возвращающий массив из имен свойст объекта х. В перечислении участвуют также свойства без enumerable`
    ],
    [
      `Object.assign(x, y)`,
      `Возвращает модифицированный объект х с добавленными к нему св-ми из объекта у. Если в целевом объекте уже существует св-во то оно будет перезаписано из крайнего левого объекта. Если целевой объект имеет методы то будет скопировано вычисление этого метода. Также не копирует свойства конфигурации(дескрипторы)`
    ],
    [
      `.valueOf()`,
      `Метод объекта который позволяет получить примитивное значение объекта отличное от строки<br>
      <b>obj.prototype.valueOf = function() { return 4; };</b> - переопределение метода`
    ],
    [
      `Регулярные выражения`,
      `<pre>
const r1 = /a/;
const r2 = new RegExp('abc', 'g');</pre>Создаются 2 способами. 1 с помощью литерала //, 2 с помощью конструктора где 1 аргумент выражение а 2 флаг<hr>
Управляющие символы:<br>
1) \\0 - null<br>
2) \\t - табуляция<br>
3) \\v - вертикальная табуляция<br>
4) \\f - перевод страницы<hr>
<b>[a,b,c]</b> - класс символов ищет 1 символ из указанных<br>
<b>[^a,b,c]</b> - тоже самое но с исключением, ищет символ не равный указанным<br>
<b>[a-zA-z0-9]</b> - указание диапазона<br>
<b>\\s</b> - пробельный символ<br>
<b>\\S</b> - не пробельный символ<br>
<b>\\w</b> - любой символ a-z && 0-9<br>
<b>\\W</b> - символ не входящий в a-z 0-9<br>
<b>\\d</b> - любое число<br>
<b>\\D</b> - любое не число<br>
<b>.</b> - любой символ за исключением переноса строки или другого разделителя строк<hr>
Символы повторений (указываются после шаблона):<br>
<b>{x, y}</b> - диапазон повторений от х до у<br>
<b>{x, }</b> - диапазон от х до неизвестно<br>
<b>{x}</b> - ровно х повторений<br>
<b>?</b> - 0 или 1 повторение<br>
<b>+</b> - 1 и более повторений<br>
<b>*</b> - 0 и более повторений<hr>
При поиске совпадений находится самая длинная цепочка из возмжных<hr>
<b>/('ab'|'ba')/</b> - группировка выражений и использование логического ИЛИ<br>
<b>/(['"])[^'"]\\1/</b> - при использовании группировки выражений их потом можно вставлять по индексу(\\n), все сгруппированные выражения получают индекс в порядке их описания в выражении слева направо. Такие ссылки нельзя вставлять в классы([])<br>
<b>(?:...)</b> - благодаря указателю данная группа не будет участвовать в индексировании и не получи ссылку<br>
<b>/(?&lt;name&gt;...)[1-4]\\k&lt;name&gt;/</b> - вместо индекса таким образом можно задать имя и использовать в дальнейшем с помощью \\k<br>
<b>\\b</b> - якорь указывающий на границы слова (напр. /\\bSome\\b/)<br>
<b>\\B</b> - якорь указывающий что шаблон не на границе слова<br>
<b>^</b> - якорь начала строки<br>
<b>$</b> - якорь конца строки<hr>
Якори просмотра позволяют добавлять к шаблону условия выборки. Они не попадают в искомый шаблон:<br>
<b>?=</b> - якорь просмотра вперед позволяет указать условие после шаблона - /[jJ]ava(?=\\:)/ - поиск слово j(J)ava после которого идет :<br>
<b>?<=</b> - аналог выше только условие до шаблона<br>
<b>?!</b> - якорь исключения - /[jJ]ava(?![sS]cript)/ - искать слово j(J)ava после которого нет слова s(S)cript<br>
<b>?<!</b> - аналог выше только для условия до шаблона<hr>
Флаги:
<b>g</b> - флаг глобального поиска<br>
<b>i</b> - флаг регистра<br>
<b>m</b> - флаг многострочного поиска<br>
<b>u</b> - флаг работы с Unicode<br>
<b>y</b> - флаг поиска на заданной позиции`
    ],
    [
      `Массив`,
      `По сути это итерируемый объект. При обращении к элементу массива индекс сначала приводится к строке а потом получаем значение как из обычного объекта<pre>
const a = [,];
const b = Array.from(5);
const c = [];
c[100] = 0;</pre>Создание разреженных массивов. Это массив в котором индексы элементов не образуют последовательную цепочку чисел начиная с 0. По сути просто массив с заданной длиной но некоторые элементы массива остаются без индекса. Такой массив занимает больше памяти и медленнее происходит поиск элементов<br>
При переборе такого массива лучше использовать forEach т.к. он не обращается к элементам undefined<br>
При использовании map() в таком массиве мы получим массив такой же длины что и исходный с элементами undefined, но в преобразовании в map они участвовать не будут<hr>
Если массиву задать длину меньше чем уже есть то элементы после индекса length - 1 пропадут. Если задать длину больше чем уже имеется то массив станет разреженным<hr>
Методы массива:<br>
1) <b>.find((x) => x === y)</b> - поиск элемента в массиве удовлетворяющему условие в cb ф-ции. Если элемент найден цикл остановится и вернет элемент, или же вернет undefined<br>
2) <b>.findIndex(calllback)</b> - тоже что и метод выше но возвращает индекс найденного элемента<br>
3) <b>.reduceRighth(callback)</b> - тоже что и reduce но начинает цикл справа налево<br>
4) <b>.flat(x?)</b> - возвращает новый массив убирая при этом уровни вложенности. Если аргумент не передан то убирает только начальный уровень. Х - необязательный аргумент указывающий сколько уровней вложенности необходимо убрать ([1, [2, 3]].flat() => [1])<br>
5) <b>.flatMap(callback)</b> - сначала сработает как map с cb ф-цией а потом применится flat<br>
6) <b>.splice(x, y, ...z);</b> - метод для вставки или удаления части массива. Х начальный индекс, у необязательный конечный индекс, z необязательные элементы. Если z не указан то просто удаляет часть массива, если указан делает вставку<br>
7) <b>.copyWithin(x, y, z)</b> - делает срез массива и вставляет его в исходный при этом видоизменяя исходный массив. Изменения происходят путем наложения нового массива на старый. х - индекс с которого начать наслоение, у - индекс с которого начать срез, z - конечный индекс среза<br>
8) <b>.join(x?)</b> - объединяет все элементы массива в строку по умолчанию через ,. Если передан аргумент то разделителем между элементами становится он<br>
9) <b>.subArray(x, y)</b> - возвращает часть массива где х начальный индекс а y конечный. В отличии от slice он не создает новый массив а просто возвращает часть существующего<hr>
Вызов метода toString() на массиве является аналогом вызова join() без аргументов и не учитывает вложенность<pre>
const o = {};
o[0] = 0;
o[1] = 1;
o.length = 2;</pre>Создание массивоподобного объекта. Теперь такой объект можно перебрать циклом for<br>
<b>Array.prototype.join.call(o, '+');</b> Массиво подобные объекты не наследуют прототип Array и потому не могут использовать методы массивов. Для вызова метода для такого объекта используется call где мы передаем сначала сам объект а затем аргументы для ф-ции которую хотим вызвать`
    ],
    [
      `Объект`,
      `Это неупорядоченная коллекция свойств, каждое из которых имеет имя и значение. Свойста имеют 3 атрибута:<br>
      1) writable - можно ли менять значение св-ва<br>
      2) enumerable - участвует ли св-во в переборах for in<br>
      3) configurable - можно ли удалять св-во или изменять его атрибуты<br>
      Все собственные св-ва имеют эти атрибуты в значении true<hr>
      Если мы попытаемся получить какое то свойство у объекта то интепритатор сначала ищет его в самом объекте. Если не находит поиск продолжается в его ближайшем наследуемом прототипе и так продолжается либо пока св-во не будет найдено, либо вернет undefined. При попытке получить свойство у не существующего свойста получим TypeError т.к. null и undefined не имеют никаких свойств<hr>
      Порядок перечисления свойств объекта:<br>
      1) сначала идут свойста чье имя является целым положительным числом, по числовому порядку<br>
      2) затем идут свойста с именем строчным в порядке в котором они были добавлены<br>
      3) далее идут свойста с именем Symbol<br>
      4) дальше все повторяется для каждого прототипа. Если свойство уже было перечислено то оно пропускается<pre>
const obj = {
  x: 5,
  get getter() {
    return this.x;
  },
  set setter(v) {
    this.x = v;
  }
};

obj.setter = 1;
console.log(obj.getter);</pre>Синтаксис get и set. Они связывают свойство объекта с определенной ф-цией и в последующем при обращении к этому св-ву она будет вызвана. При обращении к get вызывается ф-ция которая возвращает значение. При обращении к set вызываетс ф-ция устанавливающая новое значение переданное в аргумент в виде обычного присваивания значения<hr>
Некоторые методы объектов:<br>
<b>Object.isExtensible(x)</b> - проверяет является ли объект х расширяемым<br>
<b>Object.preventExtensions(x)</b> - делает получаемый объект х нерасширяемым. После этого объект уже невозможно вернуть в исходное состояние<br>
<b>Object.isSealed(x)</b> - проверяет является ли объект запечатанным<br>
<b>Object.seal(x)</b> - запечатывает объект. Делает его не расширяемым и не конфигурируемым. Свойства такого объекта нельзя удалить или изменить, можно только изменить значение св-ва<br>
<b>Object.isFrozen(x)</b> - проверяет заморожен ли объект<br>
<b>Object.freeze(x)</b> - замораживает объект. Тоже что и seal + вдобавок объект становится readonly<hr>
Некоторые св-ва объектов:<br>
<b>[Symbol.hasInstance]()</b> - этот метод является альтернативой проверки instanceof<br>
<b>[Symbol.toStringTag]()</b> - метод возвращает строковый литерал, который будет добавлен к описанию объекта при вызове на нем toString() (напр. - [Object myName])<br>
<b>[Symbol.toPrimitive](x)</b> - метод который пытается преобразовать в примитивное значение где х является переданным типом и возвращает элементарное значение объекта`
    ],
    [
      `Примеры простого зацикливания`,
      `<b>for (;;) {}</b><br>
      <b>while(true){}</b><br>
      <b>for (let k in array) {array.push(k + 1);}</b>`
    ],
    [
      `Свойства и методы node элементов`,
      `<b>.parentNode</b> - свойство содержит родительский элемент<br>
      <b>.children</b> - дочерние элементы<br>
      <b>.childElementCount</b> - кол-во дочерних элементов<br>
      <b>.firstElementChild</b> - первый дочерний элемент или null<br>
      <b>.lastElementChild</b> - последний дочерний элемент<br>
      <b>.childNodes</b> - все дочерние узлы<br>
      <b>.nextSibling</b> - следующий узел<br>
      <b>.previousSibling</b> - предыдущий узел<br>
      <b>.nodeType</b> - численный указатель типа узла (document, element, text, comment)<br>
      <b>.nodeValue</b> - текстовое содержание узла (text || comment)<br>
      <b>.nodeName</b> - имя HTML дескриптора<br>
      <b>.removeAttribute(x)</b> - удалить атрибут х<br>
      <b>.insertAdjacentHTML(x, y)</b> - вставить разметку у в элемент где х указание куда именно происходит вставка - <br>
      <b><sup>1</sup>&lt;div&gt;<sup>2</sup>some text<sup>3</sup>&lt;/div&gt;<sup>4</sup></b><br>
      1) beforebegin<br>
      2) afterbegin<br>
      3) beforeend<br>
      4) afterend`
    ],
    [
      `Собственные события`,
      `<pre>
async function some() {
  document.dispatchEvent(new CustomEvent('busy', { detail: true }));    <sup>1</sup> 
  ...some code...
  document.dispatchEvent(new CustomEvent('busy', { detail: false }));
}

document.addEventListener('busy', (e) => {
  e.detail ? showSpinner() : hideSpinner();
});

some();</pre>Создание собственного события. Сначала в пункте 1 мы инициализируем срабатывание события куда передаем конструктор нового события. Этот конструктор принимает 1 арг. название события и 2 арг. дополнительные параметры для объекта события. После мы вешаем обработчик события на элемент или документ и производим какие то действия`
    ],
    [
      `Процесс загрузки страницы`,
      `1) браузер создает Document и начинает анализ. Добавляет элементы и текстовые узлы по мере анализа. В этот момент свойство .readyState = loading<br>
      2) когда анализатор встречает &lt;script&gt; без атрибутов и модулей начинается выполнение скрипта и анализ страницы приостанавливается<br>
      3) если встречается async script то начинается его выполнение с попутно продолжающимся анализом страницы<br>
      4) после полного анализа страницы св-во .readyState = interactive. В этот момент начинается выполнение отложенных скриптов(defer)<br>
      5) далее идет инициализация DOMContentLoaded. В этот момент все еще может идти выполнение async скриптов<br>
      6) когда все сценарии выполнены и загруженны все сторонние ресурсы св-во .readyState = complete и инициализируется событие load`
    ],
    [
      `Proxy`,
      `<pre>
const obj = { x: 4 };
const proxy = new Proxy(obj, {
  get(obj, prop) {
    return 'text';
  }
});
obj.x;    // 4
proxy.x;  // 'text'</pre>Объект Proxy служит оболочкой для других объектов и позволяет перехватывать различные действия над целевым объектом. В качестве 1 аргумента принимает целевой объект а 2 аргумент это объект с настройками. Если объект пуст то все действия напрямую будут передоваться в целевой объект. При перехвате запроса на получение св-ва используется метод get который принимает 1 арг. - сам объект, 2 арг. - имя св-ва. При перехвате действия изменения св-ва объекта используется метод set. 1 арг. - целевой объект, 2 арг. - имя св-ва, 3 арг. - новое значение. В любом случае этот метод должен вернуть boolean. true если запись прошла успешно и false если нет`
    ],
    [
      `for in`,
      `<pre>
for (let k in obj) {
  console.log(obj[k]);  
}</pre>Цикл позволяет перебрать все собственные и унаследованные свойства неитерируемого объекта. Сначала идет вычисление самого объекта, затем идет вычисление переменной k, т.е. по сути создается переменная k и в нее подставляется имя свойста объекта. После всего происходит выполнение кода в теле цикла. Сам цикл видит только перечисляемые свойства, т.е. не видит методы и встроенные свойства<pre>
const obj = {
  x: 1, y: 2, z: 3
};
let a = [], i = 0;
for (a[i++] in obj) {}</pre>Благодаря вычислению переменной k из примера выше мы можем таким образом заполнить массив ключами объекта`
    ],
    [
      `switch`,
      `<pre>
const a = 4;
switch(a) {
  case 3:
    console.log(3);
    break;
  case 4:
    return 'its 4';
  default:
    console.log('not found');
    break; 
}</pre>Цикл сравнения значений переменнной. Сначала выполняется вычисление аргумента (а). Затем идет последовательное строгое сравнение со значениями в case. Сам код в case выполняется позже. Если case что то возвращает то break ставить необязательно`
    ],
    [
      `;`,
      `<b>for (const i = 0; i < arr.length; i ++ );</b> - пустой оператор. Используется редко, одно из применений при создании цикла с пустым телом`
    ],
    [
      `.keyCode`,
      `Свойство объекта event(события) позволяющая получить номер нажатой клавиши`
    ],
    [
      `delete`,
      `<b>delete obj.someKey;</b>Метод позволяет удалить свойство из объекта или массива<br>
      1) при удалении свойста из массива просто заменяет его значение на undefined<br>
      2) при успешном удалении вернет true<br>
      3) при попытке удалить несуществующее св-во вернет true<br>
      4) при удалении переменной вернет false или SyntaxError в строгом режиме<br>
      5) при удалении неудаляемого св-ва вернет false или TypeError`
    ],
    [
      `REST API`,
      `Это способ взаимодействия сайта или приложения с сервером. Основные принципы REST API:<br>
      1)Отделение клиентской части от серверной<br>
      2)Сервер должен получать только ту информацию которая необходима для отправки ответа<br>
      3)В данных запроса должно быть указано нужно ли кэшировать данные<br>
      4)Единство интерфейса. Все данные должны запрашиваться по одному URL<br>
      5)Многоуровневость. Т.е. в серверной части компоненты отделены друг от друга и ничего не знают о соседях<br>
      6)Позволяется отправка кода по запросу<br>
      Методы REST API:<br>
      1)GET получение каких то данных<br>
      2)POST отправка данных на сервер<br>
      3)DELETE удаление данных<br>
      4)PUT обновление данных`
    ],
    [
      `Типы данных`,
      `1. string<br>2. number<br>3. boolean<br>4. symbol<br>5. object<br>6. null<br>7. undefined<br>8. bigInt`
    ],
    [
      `Symbol`,
      `Символьный литерал. Принимает строковый и возвращает новый символьный. Если вызвать два раза с одним значением вернет два разных символа. Такой литерал нужен чтобы избежать перезаписи свойств объекта например<hr>
      <b>.for(x)</b> - возвращает уже созданный символ или создает новый если такого нет<br>
      <b>.keyFor(x)</b> - возвращает строковое значение символа`
    ],
    [
      `Чистая функция`,
      `Ф-ция которая удовлетворяет 2 условиям:<br>1. Не изменяет входные данные и возвращает всегда одно и тоже значение если аргументы не меняются<br>2. Не осуществляет сторонние запросы - fetch, DOM`
    ],
    [
      `Типы функций`,
      `1. declaration - function n() {} - создается до выполнения кода и такую ф-цию можно вызвать в любой части кода<br>2. expression - const a = function() {} - вызов такой ф-ции возможен после ее объявления`
    ],
    [
      `.parseInt()`,
      `Метод преобразует строку в число. Если строка начинается с числового значения то преобразование будет идти пока интерпритатор не встретит первое не числовое значение. Если же строка начинается с не числового то вернет NaN`
    ],
    [
      `Распространение событий (propagation)`,
      `Изначально любое событие восходящее, т.е. идет от target и поднимается вверх через родительские элементы до самого body. Если в обработчик передать 3 параметр true то событие будет идти по нисходящей - от родителя к target.`
    ],
    [
      `.stopPropagation()`,
      `Метод события который останавливает распространение(всплытие)`
    ],
    [
      `Функция высшего порядка`,
      `Ф-ция которая либо принимает другую ф-цию в виде аргумента либо возвращает ф-цию (map, foreach...)`
    ],
    [
      `switch()`,
      `Конструкция сравнения нескольких значений переданного аргумента<pre>
switch(x) {
  case 1: {

  }
  break;
  default: {

  }
  break;
}</pre><hr>А так выглядит группировка нескольких значений<pre>
switch(x) {
  case 1:
  case 2: {
    console.log('1 or 2');
  }
  break;
  default: {

  }
  break;
}</pre>`
    ],
    [
      `.before()`,
      `Метод элемента позволяет вставить перед ним другой элемент или строку переданную в аргумент`
    ],
    [
      `.after()`,
      `Метод элемента позволяет вставить после него другой элемент или строку переданную в аргумент`
    ],
    [
      `.preventDefault()`,
      `Метод события позволяет отключить стандартное поведение элемента на котором событие произошло`
    ],
    [
      `Погружение и всплытие в событиях`,
      `При срабатывании какого либо события оно сначала движется от корневого элемента до элемента на котором оно сработало а потом всплывает наверх. При использовании стандартного обработчика события addEventListener без 3 параметра события вызываются по всплытию. Но если указать 3 параметр true события будут вызываться в порядке погружения (capture)<pre>
&lt;div&gt;
  &lt;button&gt;Click&lt;/button&gt;
&lt;/div&gt;

document.querySelector('div').addEventListener('click', () => alert('div'));
document.querySelector('button').addEventListener('click', () => alert('button'));</pre>Например здесь при клике на кнопку сначала сработает button потом div. Но если передать 3 аргумент в обработчик с true порядок вызова измениться`
    ],
    [
      `.substr(x, y)`,
      `Метод строки обрезает текущую строку с x символа(number) y символов и возвращает новую строку`
    ],
    [
      `Объединение массивов`,
      `const ar2 = [].concat(ar1); - 1 способ. Метод concat в старых версиях сначала проверял получаемый объект на isArray и потом применял rest оператор для слияния массивов. В ES6+ теперь проверяет у массива наличие св-ва Symbol.isConcatSpreadable и если оно true объединяет сущности<hr>const ar3 = [...ar1, ...ar2, 'some']; - 2 способ через спред оператор`
    ],
    [
      `Мемоизация`,
      `Это подход который запоминает вычисления каких то ф-ций и при последующем вызове уже не тратит ресурсы на новые вычисления а выдает запомненный результат если аргументы не изменились<pre>
      const memo = (f) => {
        let result = new Map();
      
        return (...args) => {
          if (!result.has(args.toString())) {
            result.set(args.toString(), f(...args));
          }
          return result.get(args.toString());
        }
      }
      const add = (x, y) => x + y;
      const memoAdd = memo(add);
      memoAdd(2, 5); // 7
      memoAdd(2, 5); // 7</pre>Пример универсального мемоизатора ф-ций с помощью замыкания. При 1 вызове мемоизированной ф-ции происходит вычисление и запись в коллекцию. При последующих вызовах если аргументы не изменились возвращается значение из коллекции тем самым экономя ресурсы`
    ],
    [
      `Замыкание`,
      `Это ф-ция которая запоминает свои внешние переменные и имеет к ним доступ. В JS по сути все ф-ции являются замыканием. Предназначено для изоляции переменной(ых) внутри области видимости функции<pre>
const memo = (f) => {
  let result = new Map();   <sup>1</sup>

  return (...args) => {     <sup>2</sup>
    if (!result.has(args.toString())) {
      result.set(args.toString(), f(...args));  <sup>3</sup>
    }
    return result.get(args.toString());
  }
}
const add = (x, y) => x + y;
const memoAdd = memo(add);
memoAdd(2, 5); // 7
memoAdd(2, 5); // 7   <sup>4</sup></pre>Здесь мы создали мемоизатор ф-ции.<br>
1)Создаем новый экземпляр коллекции<br>
2)Возвращаем ф-цию которая в свою очередь возвращает значение из коллекции. При замыкании мы всегда должны возвращать вложенную ф-цию не важно стрелочная, анонимная или какая то еще<br>
3)Если в колеекции нет ключи представленного в виде строки переданных агрументов то создаем новый ключ где значением будет вычисление ф-ции которую передали в качестве аргумента. Т.к. это универсальный мемоизатор то мы не знаем сколько аргументов было передано поэтому используем деструктуризацию массива с аргументами<br>
4)При 2 вызове ф-ции значение уже берется из коллекции<br>
Общий принцип таков что каждый раз вызывая мемоизированную версию любой ф-ции срабатывает вложенная ф-ция. В ней происходит проверка имеет ли коллекция какой то ключ. Сначала интерпритатор JS ищет эту коллекцию в области видимости вложенной ф-ции. Когда он ее не находит то поиск продолжается во внешней области. Так может продолжаться пока не дойдет до глобальной области видимости. В итоге коллекция находится на внешней области и мы производим с ней некоторые операции. Эта область видимости будет существовать до сих пор пока на нее ссылается вложенная ф-ция поэтому при каждом вызове мемоизированной ф-ции мы работаем не с новой коллекцией а с той что уже была создана или модифицированна.<br>
<b>Если говорить еще проще то по сути мы имеем какую то ф-цию обертку в которой объявляем переменные которые хотим изолировать а затем возвращаем какую то ф-цию с логикой которая производит какие то операции с нашей(ими) переменной(ыми)</b>`
    ],
    [
      `.padStart(x, y) || .padEnd(x, y)`,
      `Методы строки позволяют добавить к строке символы - y в начало || в конец строки пока длина всей строки не будет равна x`
    ],
    [
      `Оператор нулевого слияния (??)`,
      `<b>const a = 0 ?? 'string'; => 0</b> - оператор похож на логическое или(||), но возвращает первое значение если оно не null и не undefined. Разница между ними в том что ?? может возвращать логическое не (0, '', false)`
    ],
    [
      `typeof`,
      `<b>const a = typeof 'text';</b> - оператор возвращает текстовое значение типа. По скольку для объектов и массивов будет возвращать 'Object' то его задача отделять примитивы от более сложных структур`
    ],
    [
      `.every()`,
      `Метод массива проверяет каждый элемент на истину где условие описывается в callback. Вернет true если массив пустой или все элементы удовлетворяют условию`
    ],
    [
      `Условный доступ и условный вызов`,
      `<pre>
const a = { b: null };
a.b?.c = 4;</pre>В данном примере используется условный доступ к св-ву объекта. Оператор ? проверяет выражение слева на null/undefined и если это так прекращает проверку и вернет undefined<pre>
someFunction?.();</pre>Здесь происходит условый вызов ф-ции. Если ф-ции не существует то ошибки не будет. Однако если someFunction не ф-ция мы получим ошибку TypeError потому что условный оператор не проверяет тип и лишь сравнивает с null/undefined`
    ],
    [
      `Деструктуризация`,
      `позволяет разложить обьект или массив сразу на переменные.<hr><pre>
const [a, , b, c = 4] = array;</pre>Деструктуризация массива где мы получаем переменные a b c которые соответствуют элементам массива в том порядке в котором мы их обьявили. При этом если с в массиве не существует то по умолчанию ей присвоится значение 4<br>
<b>const [a, ...b] = 'hello';</b> - при деструктуризации массива справа может быть любой итерируемый объект<pre>
const {name: newVar, age: newAge = 12} = object;</pre>Деструктуризация объекта где для имен переменных мы переименовываем свойста обьекта, а также если age не задан ему будет присвоено значение 12.<br>
<b>const {floor: anotherName} = Math;</b> - деструктуризация объекта с вынесением метода в переменную anotherName. Если у объекта нет такого свойства то значением в переменной будет undefined`
    ],
    [
      `.target`,
      `свойсто объекта события(event) возвращающее элемент на котором произошло событие`
    ],
    [
      `.endsWith()`,
      `метод объекта строки возвращающий bool. Проверяет заканчивается ли строка на аргумент переданный в метод`
    ],
    [
      `.sort()`,
      `Метод массива возвращает отсортированный массив по алфавиту (при этом изменяет исходный массив), где числовые значения также переводятся в строку. Для сортировки по числу можно в метод передать callback где будет описано как x относится к y. Если результат сравнения положительный то х будет в начале и наоборот - <pre>
array.sort((x, y) => {
  return x - y;
});</pre>`
    ],
    [
      `.currentTarget`,
      `свойсто объекта события(event) возвращающее элемент на котором сработал обработчик события`
    ],
    [
      `document.createDocumentFragment()`,
      `Создает оболочку контейнер для каких то элементов для последующей вставки в другой элемент. При вставке сам фрагмент исчезает, остаются лишь дочерние элементы`
    ],
    [
      `.offsetWidth`,
      `Свойство элемента позволяет получить его полную ширину включая border и padding`
    ],
    [
      `.cloneNode()`,
      `Копирует элемент. Если в аргумент метода передан true то также копирует и дочерние элементы`
    ],
    [
      `Array.from()`,
      `Преобразует псевдомассив или массивоподобный объект в массив. В качестве аргумента принимает 1 обязательный - объект и 2 необязательный - callback который позволяет как то обработать каждый элемент<br><b>Array.from([1,2,3], x => x + x) => [2,4,6]</b><hr>
      <b>const arr = Array.from({length: count}, () => 'x');</b> - также можно создавать массивы передав объект со свойстом length и callback который будет возвращать какое то значение для дальнейшего подставления в массив`
    ],
    [
      `.querySelector()`,
      `Поиск по DOM дереву определенного элемента.<hr>'input[checked]' - делает выборку полей выбранных именно при разметке страницы<hr>'input:checked' - делает выборку полей выбранных уже в процессе какого то взаимодействия`
    ],
    [
      `.querySelectorAll()`,
      `Поиск по DOM дереву всех элементов переданных в аргумент. Возвращает псевдомассив. Чтобы воспользоваться обычными методами массива можно преобразовать полученный результат в массив => <b>const ar = [...document.querySelectorAll('div')];</b>`
    ],
    [
      `.setAttribute()`,
      `Позволяет установить атрибут элементу. Пример - <br><pre>
el.setAttribute('style', 'background: red;');</pre>`
    ],
    [
      `.test(r)`,
      `Метод строки возвращает bool если строка имеет или нет вхождение поиска`
    ],
    [
      `Видимость документа`,
      `У объекта document есть св-во visibilityState которое содержит visible - когда документ виден(мы находимся на текущей вкладке) и hidden - когда документ не видно(при переключении на другую вкладку). Для отслеживания изменения состояния видимости можно подписаться на событие документа - <b>'visibilityChange'</b>`
    ],
    [
      `window.getComputedStyle(e)`,
      `Возвращает объект с вычисленными свойствами CSS (даже те что не указаны явно) элемента - e. Все свойста при этом readonly а также все относительные величины становятся фиксированными`
    ],
    [
      `WebSocket`,
      `Веб сокеты позволяют поддерживать непрерывную связь с сервером а также обмениваться сообщениями<br>
      <b>const ws = new WebSocket('wss://...');</b> - создание веб сокета<br>
      <b>ws.send(someData);</b> - отправка сообщений на сервер<br>
      Чтобы получать сообщения с сервера необходимо зарегистрировать обработчик событий для экземпляра web socket на событие message`
    ],
    [
      `.elementFromPoint(x, y)`,
      `Метод объекта document возвращающий найденный элемент по координатам х и у`
    ],
    [
      `AbortController`,
      `<pre>
const abort = new AbortController();
fetch(url, { signal: abort.signal });</pre>Контроллер для отмены запроса. Сначала создается новый экземпляр а затем передается в запрос в качестве параметра signal само свойство signal контроллера. Теперь при необходимости можно вызвать метод .abort() чтобы отменить запрос`
    ],
    [
      `.some()`,
      `Метод массива проверяющий подходит ли хоть 1 элемент условию переданному в callback. `
    ],
    [
      `Object.entries(a)`,
      `Принимает объект в виде аргумента и возвращает его уже в виде массива с массивами - [['prop1', 'value1'], ['prop2', 'value2']]`
    ],
    [
      `.getAttribute()`,
      `Возвращает значение атрибута элемента, переданного через аргумент метода.`
    ],
    [
      `.classList`,
      `Позволяет оперировать классами на целевом элементе<br>add() - добавить<br>remove() - удалить<br>toggle() - сменить<hr>Если сначала нужно удалить класс а затем его восстановить то между этими операциями нужно произвести какие то изменения с элементом иначе браузер проигнорирует эти операции. Пример:<pre>
el.classList.remove('some-class');
el.offsetWidth = el.offsetWidth;
el.classList.add('some-class');</pre><hr>el.classList.item(n) - позволяет получить n - элемент из массива классов`
    ]
  ],
  JQUERY: [
    [
      `$.trim()`,
      `Удаляет пробелы в строке`
    ],
    [
      `.html()`,
      `Метод объекта JQUERY позволяющий получить или установить(если передан аргумент) текст вместе с разметкой внутри выбранного тега`
    ],
    [
      `.attr(x, y)`,
      `Метод объекта JQUERY позволяющий установить атрибут где х имя а у значение, при этом перезаписывает предыдущие значения`
    ],
    [
      `.src`,
      `Свойство объекта JQUERY позволяющее получить или изменить атрибут src элемента`
    ],
    [
      `.alt`,
      `Свойство объекта JQUERY позволяющее получить или изменить атрибут alt элемента`
    ],
    [
      `.className`,
      `Свойство объекта JQUERY позволяющее получить или изменить атрибут class элемента. Само свойство вовзращает перечисление всех классов в 1 строке`
    ],
    [
      `.append(x) / .prepend(x)`,
      `Методы объекта JQUERY позволяющие добавить элемент x(напр: &lt;p&gt;text&lt;/p&gt;) в конец / в начало найденного элемента`
    ],
    [
      `.appendTo(x) / .prependTo(x)`,
      `Методы объекта JQUERY позволяющие добавить найденный элемент в элемент x.`
    ],
    [
      `.wrap(x)`,
      `Метод объекта JQUERY позволяющий обернуть 1 или несколько найденных элементов в тег x(напр: &lt;p&gt;&lt;/p&gt;)`
    ],
    [
      `.remove()`,
      `Метод объекта JQUERY позволяющий удалить выбранный элемент`
    ],
    [
      `.bind()`,
      `Метод объекта JQUERY позволяющий добавить событие на определенный элемент как addEventListener, но работает только для элементов созданных именно в разметке`
    ],
    [
      `.on()`,
      `Метод объекта JQUERY позволяющий добавить событие на элемент независимо от того как он был создан`
    ],
    [
      `.empty()`,
      `Метод объекта JQUERY позволяющий удалить все внутри выбранного элемента`
    ],
    [
      `.remove()`,
      `Метод объекта JQUERY позволяющий удалить выбранный элемент`
    ],
    [
      `.clone()`,
      `Метод объекта JQUERY позволяющий полностью скопировать элемент`
    ],
    [
      `.replaceWith(x)`,
      `Метод объекта JQUERY позволяющий заменить найденный элемент на элемент x`
    ],
    [
      `.text()`,
      `Метод объекта JQUERY позволяющий получить или изменить только текстовое содержимое элемента`
    ],
    [
      `.animate(x, y)`,
      `Метод объекта JQUERY позволяющий задать анимацию элементу где x - объект в котором описанны свойства и значения которые должны изменится ({scrollTop: 500}), а y - время анимации в мс`
    ],
    [
      `Выборка с исключением`,
      `<b>$('x:not(y)')</b> - Выборка элементов х но только тех что не подходят условиям в у. Например - $('a:not(a[href])') - выбрать все элементы a у которых нет атрибута href<br><b>$(x).not(y)</b> - аналогичная запись. Например - $('a').not('a[href]')`
    ],
    [
      `Скрытие / показ элементов`,
      `Чтобы скрыть или показать элементы можно применить следующие методы:<br><b>.hide()</b> - скрывает в виде изменения высоты<br><b>.show()</b> - показывает в виде изменения высоты<br><b>.slideUp() / .slideIn()</b> - в виде свертьывания<br><b>.fadeOut() / .fadeIn()</b> - в виде изменения прозрачности<br>Все эти методы могут принимать в себя 2 необязательных параметра:<br>
      1. время в мс указывающее на скорость анимации<br>
      2. callback ф-цию которая выполнится после анимации`
    ],
    [
      `.css(x, y)`,
      `Метод объекта JQUERY позволяющий изменять различные стили элемента(например: css('color', 'red')), где y так же может быть ф-цией (css('color', () => {return ...}))`
    ],
    [
      `.val()`,
      `Метод объекта JQUERY позволяющий изменять или получать значение из атрибута value найденного элемента`
    ],
    [
      `$('x:y')`,
      `Выборка в JQUERY с помощью пвсевдоклассов, где х - элемент а у:<br>1) first/last - позволяет выбрать 1 или последний элемент в полученной коллекции<br>2) eq(n) - позволяет выбрать определенный элемент из коллекции где n - индекс элемента<br>3) cheched - позволяет выбрать элементы с атрибутом checked(например радио кнопки)`
    ],
    [
      `.get(n)`,
      `Метод JQUERY позволяет выбрать определенный элемент из выбранной коллекции где n - индекц элемента(начинается с 0)`
    ]
  ],
  React: [
    [
      'Быстрое создание проекта на React',
      `<b>npm i create-react-app x</b> - Быстрое создание макета для приложения где х необязательный параметр указывающий на имя папки с проектом<br><b>npx create-react-app x --template у</b> - Быстрое создание макета приложения по шаблону переданному в у(например redux)`
    ],
    [
      'Объект события в React',
      `При обработке события какого либо элемента также можно обращаться к объекту события (evt) как и в обычном JS. Но React использует обертку SyntheticEvent там есть все тоже что и в обычном nativeEvent. Если есть необходимость получить нативный объект можно обратиться к свойству - <b>evt.nativeEvent</b><hr>
      Чтобы поймать событие на стадии перехвата можно использовать props <eventName>Capture. Например - <b>&lt;button onClickCapture={someHandler} /&gt;</b><hr>
      При добавлении обработчика события React не добавляет его в DOM элемент а делегирует его на главный контейнер(div root) где там уже идет распределение`
    ],
    [
      'Virtual DOM',
      `Паттерн позволяющий обновлять интерфейс более оптимальным способом. По сути это объект хранящийся в памяти, являющийся посредником между DOM и кодом. Сначала все изменения происходят на нем а затем переносятся на реальный DOM`
    ],
    [
      'useParams()',
      `<pre>
const Component = () => {
  const params = useParams();
  ...
  render();
}</pre>Позволяет получить переданные параметры в адресную строку (ID и т.д.). Сам хук возвращает объект который имеет свойста названные так как было указано в маршрутизации (...url.../:id)`
    ],
    [
      'Различные фишки',
      `Если на 1 странице имеется скроллбар а на 2 нет, то при переходе контент будет прыгать в стороны. Чтобы избежать этого контейнеру можно задать свойство <b>margin-left: calc(100vw - 100%);</b>`
    ],
    [
      'useRef()',
      `<pre>
const SomeComp = () => {
  const formRef = useRef(null);
  return (
    &lt;Form ... ref={formRef}&gt;
      ...
    &lt;/Form&gt;
    {
      formRef.current && &lt;p&gt;Данные формы полученны&lt;/p&gt;
    }
  ); 
}</pre>Хук useRef позволяет получить доступ к элементу на странице но только после отрисовки компонента. Необходим для работы с неконтролируемыми элементами а также сторонними ресурсами и просто чтобы получить доступ к DOM. Сам элемент хранится в свойстве current`
    ],
    [
      'useCallback()',
      `<pre>
const SomeComp = () {
  const eventHandler = useCallback(() => {
    ...
  }, []); 
  return (
    &lt;AnotherComp someProp={eventHandler} /&gt;
  );
}</pre>По скольку чтобы изменить что то в родительском элементе из дочернего необходимо передать какойто callback, то для того чтобы избежать лишних перерисовок(мемоизация) используется хук useCallback, который мемоизирует переданную callback функцию. В качестве параметра принимает в себя необходимую ф-цию и возвращает уже обернутую ф-цию`
    ],
    [
      'Выпадающий список',
      `<pre>
const SomeComp = () => {
  const [select, setSelect] = useState('a');
  return (
    &lt;select value={select}&gt;
      &lt;option value='a' /&gt;
      &lt;option value='b' /&gt;
    &lt;/select&gt;
  ); 
}</pre>Если в обычном HTML чтобы указать какой то элемент из выпадающего списка выбранным достаточно указать ему свойство selected, то в JSX разметке необходимо задать свойству value самого select значение необходимого элемента списка`
    ],
    [
      'Контролируемые формы',
      `<pre>
const SomeComp = () => {
  const [formData, setFormData] = useState({name: '', age: ''});
  
  const changeHandler = (e) => {
    const {name, value} = e.target;
    setFormData({...formData, [name]: value}));
  }

  return (
    &lt;input name='name' onChange={changeHandler} value={formData.name} /&gt;
  );
}</pre>Создание контролируемой формы. Сначала создаем внутренне состояние с начальными значениями формы. Затем создаем обработчик события изменения поля формы где с начала получаем данные name и value а затем записываем их в состояние. После вешаем обработчик на поля формы. И обязательно задаем в свойство value значение из созданного состояния. Если этого не сделать то состояния начнут дублироваться`
    ],
    [
      'Сброс прокрутки страницы',
      `<pre>
function ScrollTop() {
  const {pathname} = useParams();
  useEffect(() => {
    window.scrollTo(0,0);
  }, pathname); 
  return null;
}

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;ScrollTop&gt;
        &lt;Routes&gt;
          ...
        &lt;/ScrollTop&gt;
      &lt;/ScrollTop&gt;
    &lt;/BrowserRouter&gt;
  ); 
}</pre>Компонент позволяющий сбросить прокрутку страницы в 0 т.к. при перерисовки компонентов скролл остается на прежнем месте. Такой компонент можно поместить в главный компонент(App). Для этого просто оборачиваем Routes в наш компонент. Внутри компонента используется хук useEffect подписанный на изменение адреса страницы и возвращает он null чтобы ничего не отрисовывать`
    ],
    [
      'NavLink',
      `Тоже самое что и компонент Link только + еще умеет отслеживать открыт ли сейчас URL на который указана ссылка<pre>
&ltNavLink to="some" className={({isActive}) => {
  return isActive ? 'link--active' : 'linl';
}} /&gt;</pre>
      Также вместо строки с классами в пропс className он принимает cb ф-цию которая принимает bool флаг и взависимости от него возвращает строку с тем или иным классом. Также пропс style принимает cb ф-ци`
    ],
    [
      'Создание собственного хука',
      `<pre>
const useFilm = (id) => {
  const [film, setFilm] = useState({});
  useEffect(() => {
    let update = true;
    fetch('some.json')
      .then(resp => resp.json())
      .then(resp => update && setFilm(resp));
  }, [id]);
  return film;
}
...
const SomeComp = (props) => {
  const film = useFilm(props.id);
  ... 
}</pre>Создание и использование своего хука который делает запрос и возвращает объект с данными`
    ],
    [
      'Маршрутизация REACT компонентов',
      `<pre>
&lt;BrowserRouter&gt;
  &lt;Routes&gt;
    &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
      &lt;Route index element={&lt;Main /&gt;} /&gt;
      &lt;Route path="about" element={&lt;About /&gt;} /&gt;
    &lt;Route /&gt;
  &lt;/Routes&gt;
&lt;/BrowserRouter&gt;</pre>Маршрутизация компонентов, где в данном примере компонент Layout остается неизменным независимо от маршрута, а меняется только часть его содержимого (в том месте где стоит компонент &lt;Outlet /&gt;). Index означает главную страницу.<pre>
&lt;Route path="*" element={&lt;NotFoundComponent /&gt;} /&gt;</pre>Маршрутизация для несуществующих страниц. Этот рут ставится в конце списка и означает что любой путь перенаправляет на компонент NotFoundComponent<pre>
&lt;Route path="/about/:id" element={&lt;SomeComp /&gt;} /&gt;

function SomeComp() {
  const {id} = useParams();
  ... 
}</pre>Передача параметров в путь и использование его в компоненте<pre>
&lt;Route path="/about" element={&lt;Some /&gt;} &gt;
  &lt;Route path=":id" element={&lt;Some /&gt;} /&gt;
&lt;/Route&gt;

function Some() {
  const params = useParams();
  if (params.id) {
    ...
  }
  ...
  } 
}</pre>Чтобы не потерять просто страницу about можно сделать ее вложенной тогда у нас будет отображаться и просто страница и страница с переданными параметрами<pre>
app.jsx

...
&lt;Route path="favorites" auth="no_auth" element={
  &lt;PrivateRoute&gt;
    &lt;FavoriteScreen /&gt;
  &lt;PrivateRoute /&gt;
} /&gt;

PrivateRoute.jsx

function PrivateRoute(props) {
  return props.auth === "no_auth"
    ? &lt;Navigate to="/" /&gt;
    : props.children;
}</pre>Приватный путь. Если переданный props auth является no_auth то происходит переадесация на главную страницу. Или же возвращается дочерний элемент (children это служебное свойство props в котором хранится дочерний элемент)`
    ],
    [
      'Свой API в классовых компонентах',
      `<pre>
class MyApi {
  constructor() {
    this.baseUrl = 'someUrl';
  }
  getData = async (url) => {
    const res = await fetch(this.baseUrl + url);
    if (!res.ok) {
      throw new Error('Something goes wrong');
    }
    const result = await res.json();
    return result;
  }
}</pre>Создание своего API сервиса с помощью класса. В конструкторе указываем базовый URL. В метод getData передается часть URL где мы делаем асинхронный запрос. Если ответ приходит со статусом != 200 вернем ошибку, если же все хорошо обрабатываем ответ и возвращаем в виде JSON`
    ],
    [
      'Контекст',
      `Контекст предназначен для того чтобы передавать props на прямую от 1 компонента до другого игнорируя прописывание его во всей цепочке наследования<br><b>context.js</b><br><b>const MyContext = React.createContext();</b> - создаем экземпляр контекста<br><b>app.js</b><pre>
const App = () => {
  return (
    &lt;MyContext.Provider ... value={{someValue: 'hello'}}&gt;
      &lt;SomeComp /&gt;
    &lt;/MyContext.Provide&gt;
  ) 
}</pre>В самом главном компоненте оборачиваем все в MyContext.Provider и через атрибут value передаем необходимые props<br><b>somecomp.js - функциональный</b><pre>
const SomeComp = () => {
  return (
    &lt;MyContext.Consumer&gt;
      {
        (value) => {
          return (
            &lt;p&gt;{value.someValue}&lt;/p&gt;
          )
        }
      }
    &lt;/MyContext.Consumer&gt;
  ) 
}</pre>Использование контекста в функциональном компоненте, для этого сначала необходимо все обернуть в MyContext.Consumer<br><b>somecomp.js - классовый</b><pre>
class SomeComp extends Component {
  ...
  render() {
    return (
      &lt;p&gt;{this.context.someValue}&lt;/p&gt;
    )
  } 
}
SameComp.contextType = MyContext;</pre>В классовом компоненте получаем доступ к контексту через this.context. Но для того чтобы использовать контекст в классовом компоненте необходимо в свойство этого компонента contextType передать ранее созданный контекст`
    ],
    [
      'Глобальное состояние в классовом компоненте',
      `<b>reducer.js</b><pre>
const initState = {
  value: [],
  trigger: false  
}
const reducer = (state = initState, action) => {
  switch(action.type) {
    case 'LOAD_VALUE':
      return {
        ...state, value: action.payload
      };
      break;
    default: return state;
  } 
}
export default reducer;</pre>Сначала описывается сам reducer. Это ф-ция которая в зависимости от полученного action производит какие то действия с глобальным хранилищем(store). 1 аргумент это сам store и сразу же присваеваем ему начальное состояние. 2 аргумент это объект action который содержит поле type в котором находится описание действия и поле payload которое содержит данные для обновления store. Далее в конструкции switch идет перебор действий где описывается логика изменения store<br><b>actions.js</b><pre>
const loadValue = (value) => ({type: 'LOAD_VALUE', payload: value});
export {loadValue};</pre>Здесь уже описываются сами действия. По сути это функция которая возвращает объект содержащий 2 или 1 поле в зависимости от переданного в нее аргумента. Поле type содержит описание действия для reducer а не обязятельное поле payload содержит какое то значение из переданного аргумента<br><b>index.js</b><pre>
...
&lt;Provider store={store}&gt;
  &lt;App /&gt;
&lt;/Provider&gt;</pre>В главном файле глобальное состояние подключается через обертку Provider для того чтобы каждый компонент внутри видел это состояние<br><b>store.js</b><br><b>const store = createStore(reducer);</b> - с помощью библиотеки redux создаем глобальное хранилище передав в качестве аргумента созданный ранее reducer<br><b>someComp.js</b><pre>
class Somecomp extends Component {
  ...
  render() {
    const {someValue, loadValue} = this.props;
    ...
  } 
}
const mapStateToProps = (state) => ({
  someValue: state.value
})
const mapDispatchToProps = {
  loadValue 
}
export connect(mapStateToProps, mapDispatchToProps)(Somecomp);</pre>Внизу сначала мы создаем 2 ф-ции которые возвращают объект со значениями из store и объект с нашими actions, а затем через connect библиотеки react-redux привязывам эти ф-ции к компоненту чтобы взаимодействовать с состоянием в виде props, где:<br>1 аргумент объект со значениями<br>2 аргумент объект с actions<br>3 аргумент сам компонент<br>А в самом компоненте уже получаем это все через this.props(в функциональном компоненте эти props будут переданны как обычный аргумент в ф-ции)`
    ],
    [
      'Параметры в функциональных компонентах',
      `Компонент может принимать параметры для дальнейшего использования. Если меняются передаваемые параметры то компонент перерисовывается. Сам компонент принимает параметры через объект props, который можно либо деструктуризировать в блоке с логикой(пример 1) либо сразу при объявлении ф-ции(пример 2). А сами параметры передаются уже при использовании компонента в виде обычного атрибута(пример 3)<pre>
function Some(props) {
  const {someProp} = props;
  ... 
}
function Another({someProp}) {
  ... 
}
...
root.render(&lt;Some someProp="something" /&gt;);
</pre>`
    ],
    [
      'Функциональный компонент',
      `<pre>
const Some = () => {
  const text = () => {
    return 'text';
  }
  const style = {
    width: '300px'
  } 
  return (
    &lt;p className="class" style={style}&gt;{text ? text : null}&lt;/p&gt;
  )
}</pre>Создание функционального компонента, где сначала идет блок с какой то логикой а в конце возвращается разметка, в которой можно использовать различные переменные указав их в {} как для контента так и для атрибутов. Также можно использовать ТОЛЬКО тернарный оператор для различных условий`
    ],
    [
      'Передача props компоненту',
      `<pre>
const SomeComp = () => {
  return (
    &lt;AnotherComp name="Bob" age={45} /&gt;
  ); 
}</pre>Обычный способ передачи props<pre>
const SomeComp = () => {
  const props = { name: 'Bob', age: 45 };
  return (
    &lt;AnotherComp {...props} /&gt;
  ); 
}</pre>Определение объекта пропсов в логике компонента и передача с помошью деструктуризации`
    ],
    [
      'Типизация props children',
      `<pre>
type AppProps = {
  someProp: number;
  children?: ReactNode; 
}</pre>В данном псевдониме проп children отмечен как не обязательный и имеет тип ReactNode который в свою очередь является псевдонимом типов  ReactChild | ReactFragment | ReactPortal | boolean | null | undefined<pre>
type SomeProps = PropsWithChildren&lt;{
  someProp: number;
}&gt;;</pre>В React уже есть готовый шаблон если нам необходимо описать тип props в котором возможно есть children. Данный шаблон использует дженерик и выглядит следующим образом - <b>type PropsWithChildren&lt;T&gt; = T & { children?: ReactNode | undefined };</b><pre>
function SomeComp: React.FC&lt;SomeTypeProps&gt;(props) {
  ...
}</pre>Еще 1 подход типизации children. Здесь используется встроенный интерфейс FunctionComponent который также с помощью дженерика принимает другой псевдоним типа. Но такой подход не следует использовать т.к. он скрывает типизацию children`
    ],
    [
      'JSX разметка',
      `1) вместо class используется className<br>
      2) вместо атрибута for пишется htmlFor<br>
      3) при использовании boolean параметра можно не указывать его значение если оно равно true, а всего лишь имя переменной<br>
      4) события в разметке указываются как атрибуты элементов <b>onX</b> где x имя события(click, submit) а в качестве значения принимает ф-цию которая описана в логике<br>
      5) вместо &lt;a href="#"&gt; используется <b>&lt;link to="#"&gt;</b> потому что при использовании обычной ссылки страница будет перезагружаться<br>
      <pre>
function SomeComp() {
  return (
    &lt;h1 style={{
      color: 'red',
      fontSize: '500px',
    }}&gt;Hello&lt;/h1&gt;
  ); 
}</pre>Описание стилей внутри элемента происходит следующим образом. Стили в JSX это объекты, поэтому сначала открываются фигурные скобки для вставки JS кода а затем вставляется сам объект где свойста стилей являются полями объекта описаные в camelCase<pre>
function Some() {
  return '&lt;p&gt;Hello wolrd&lt;/p&gt; 
}</pre>При попытке отрендерить строку с разметкой JSX автоматические экранирует такую строку и просто выведет весь код в строке<pre>
function App() {
  return <div dangerouslySetInnerHTML={{ __html: Some()}}></div>
};</pre>Однако такое поведение можно исправить указав соответствующий атрибут передав в него объект с компонентом. Но это опасно<pre>
const MyComp = () => {
  const variable = false;
  return (
    &lt;div&gt;
      Моя переменная - {String(variable)}
    &lt;/div&gt;
  ); 
}</pre>Чтобы отобразить ложное значение его сначала надо представить в виде строки как здесь например<hr>
JSX разметка по итогу интерпретируется в JS объект поэтому если в разметке имеются несколько элементов то у них должен быть какой то общий элемент или хотя бы обёртка иначе JS воспримет их как 2 несвязанных объекта и мы получим ошибку`
    ],
    [
      'Организация редиректа не из компонента',
      `<b>browser-history.js</b><pre>
const browserHistory = createBrowserHistory();</pre>Сначала просто создаем новый экземпляр browser history<br><b>history-route.js</b><pre>
function HistoryRouter({history, basename, children}) {
  const [state, setState] = useState({
    action: history.action,
    location: history.location
  });
  
  useLayoutEffect(() => history.listen(setState), [history]);
  return (
    &lt;Router
      basename={basename}
      location={state.location}
      navigationType={state.action}
      navigator={history}
    &gt;
      {children}
    &lt;/Router&gt;
  );
}</pre>Описываем компонент обертку для Router<br><b>index.js</b><pre>
&lt;HistoryRouter history={browserHistory}&gt;
  ...
&lt;/HistoryRouter&gt;</pre>В точке входа приложения вместо BrowserRouters подставляем наш компонент<br><b>redirect.ts</b><pre>
const redirect = (store) => (next) => (action) => {
  if (action.type === 'redirectToRoute') {
    browserHistory.push(action.payload);
  } 
  return next(action);
}</pre>Создаем свой middleware для редиректа`
    ],
    [
      'Привязка контекста в классовом компоненте',
      `1) через bind в конструкторе => <b>this.changeState = this.changeState.bind(this)</b><br>2) записать стрелочную ф-цию в конструктор где контекстом автоматически станет родитель => <b>this.changeState = () => {}</b><br>3) Благодаря новому стандарту можно использовать стрелочную ф-цию вне конструктора => <b>changeState = () => {}</b>`
    ],
    [
      'HOC для классового компонента',
      `<pre>
const withData = (SomeComponent) => {
  return class extends Component {
    state ...
    componentDid...
    render() {
      ...
      return &lt;SomeComponent {...this.props} data={data} /&gt;
    }
  } 
}</pre>Создание обертки для классового компонента с целью добавить какой то новый функционал. Эта обертка возвращает безымянный класс который содержит какую то логику и в конце рендерит переданный компонент. По скольку обертка также видит props то просто передаем их с помощью деструктуризации а также добавляем новый(data)<hr>HOC уместен когда:<br>1) поведение необходимо для нескольких элементов<br>2) поведение не требует большого кол-ва props`
    ],
    [
      'HOC для функционального компонента',
      `<pre>
const withFlag = (Component) => function(props) {
  const [isOn, setIsOn] = useState(false);
  return (
    &lt;Component {...props} isOn={isOn} onChange={() => setIsOn(!isOn)} /&gt;
  ); 
}

const SomeComp = (props) => {
  return(
    &ltbutton isOn={props.isOn} onClick={props.onChange} /&gt;
  );
}
export default withFlag(SomeComp);</pre>Создание обертки для функционального компонента с целью добавить какой то новый функционал. Эта обертка возвращает анонимную ф-цию которая содержит какую то логику и в конце рендерит переданный компонент. По скольку обертка также видит props то просто передаем их с помощью деструктуризации а также добавляем новый<hr>HOC уместен когда:<br>1) поведение необходимо для нескольких элементов<br>2) поведение не требует большого кол-ва props`
    ],
    [
      'Жизненные циклы в классовом компоненте',
      `<b>componentDidMount() {}</b> - ф-ция которая сработает при 1 рендере компонента<br><b>componentDidUpdate(prevProps, prevState) {}</b> - ф-ция которая сработает при обновлении props или state, которая также принимает 2 аргумента в виде предыдущих значений props и state для проверки на изменения<br><b>componentDidCatch() {}</b> - ф-ция обработчик ошибок для того чтобы не рушилось все приложение<br><b>componentWillUnmount() {}</b> - ф-ция которая сработает как только компонент будет уничтожен`
    ],
    [
      'useMemo()',
      `<b>const memoFunc = useMemo(someFunc, []);</b> - хук который создает мемоизированную версию переданной в него ф-ции.`
    ],
    [
      'Селекторы',
      `<b>const getData = (state) => state['DATA'].someData</b> - селектор для безопасной работы с глобальным состоянием<br>
      <b>const data = useSelector(getData);</b> - использование хука для работы с созданным селектором`
    ],
    [
      'Комбинирование/нарезка reducer',
      `<b>data-reducer.js</b><pre>
const dataReducer = createSlice({
  name: 'DATA',
  initialState: initState,
  reducers: {},
  extraReducers(builder) {
    builder
      .addcase(someAsyncAction.fullfiled, (state, action) => {
        state.prop = action.payload;
        state.isLoading = false;
      })
      .addcase(someAsyncAction.pending, (state) => {
        state.isLoading = true;
      })
      .addcase(someAsyncAction.rejected, (state) => {
        state.isError = true;
        state.isLoading = false;
      });
  }
});</pre>Создаем 1 часть общего reducer которая будет отвечать за работу с данными. Создается с помощью ф-ци createSlice которая принимает объект со следующими полями:<br>
1)Имя reducer для дальнейшего обращения<br>
2)Начальное состояние<br>
3)Объект с методами для синхронных операций, в данном примере пуст<br>
4)Метод для работы с асинхронными операциями. В нем на переданном объекте по цепочке вызывается метод addCase чтобы добавить новые операции. Этот метод принимает асинхронный action с 1 из 3 свойств означающих статус обработки(fullfiled - успешно выполненый/pending - в процессе обработки/rejected - не выполнен). Для каждого из этих свойств по надобности создаются обработчики. В качестве 2 аргумента принимается callback содержащий state в виде 1 аргумента и action в виде необязательного 2 для того чтобы была возможность получить какие то полученные данные из action<br><b>user-reducer.js</b><pre>
const userReducer = createSlice({
  name: 'USER',
  initialState: initState,
  reducers: {
    clearData: (state) => {
      state.someData = null;
    }
  }
});
export const {clearData} = userReducer.actions;</pre>Создаем 2 часть reducer. Она отвечает за какое то пользовательское взаимодействие и тут мы уже описываем обычные обработчики action в виде методов. При использовании простых обработчиков action в конце нужно экспортировать их для дальнейшего использования<br><b>root-reducer.js</b><pre>
const rootReducer = combineReducers({
  ['DATA']: dataReducer.Reducer,
  ['USER]: userReducer.Reducer
});</pre>Создание общего reducer из нарезок. После этого полученный reducer можно как обычно передать в store`
    ],
    [
      'Мемоизация компонента',
      `<pre>
const SomeComp = (props) => {
  ...
}
export default memo(SomeComp, (prev, curr) => {
  return prev.count === curr.count;
});</pre>Мемоизация компонентов нужна чтобы избежать лишней перерисовки. В данном случае используется обертка(HOC) memo которая принимает в качестве 1 обязательного аргумента компонент и 2 необязательный - callback. Если передать один аргумент то HOC просто сравнивает props компонента поверхностно и если они изменились то перерисует компонент. Однако если в props есть callback ф-ции то перерисовка не избежна. Чтобы это избежать мы можем применить <b>КОСТЫЛЬ</b>, передать 2 аргумент ф-ции которая будет возвращать какой то результат сравнивания, например сравнивая отдельные props как в примере с count. И если ф-ция вернет false компонент перерисуется.`
    ],
    [
      'Axios',
      `Библиотека для отправки HTTP запросов в браузере. Преимущества:<br>
      1)отображение прогресса<br>
      2)автоматическая трансформация ответа в JSON<br>
      3)поддержка node.js<br>
      4)имеет интерфейс для написания сетевых запросов<br>
      5)моки для тестов из коробки<br>
      6)наличие перехватчиков ответов и запросов<pre>
const createAPI = (): AxiosInstance => {
  const api = axios.create({  <sup>1</sup>
    baseURL: 'someUrl',
    timeout: 5000
  });

  api.interceptors.request.use((config: AxiosRequestConfig) => {  <sup>2</sup>
    const token = getToken();

    if (token) {
      config.headers['x-token'] = token;
    }

    return config;
  });

  api.interceptors.response.use((resp) => resp, (error: AxiosError) => {  <sup>3</sup>
    if (error.response) {
      someErrorHandler(error.response.data.error);
    }
    throw error;
  });

  return api; 
}</pre>Создание REST API с помощью axios.<br>
1)создаем api с помощью конструктора передав в него объект с настройками - URL и время ожидания ответа<br>
2)добавляем перехватчик запроса. В нем мы получаем токен и если токен получен добавляем к конфигу его в виде заголовка и в конце возвращаем обновленный конфиг<br>
3)добавляем перехватчик ответа. В нем мы смотрим если с ответом все в порядке просто возвращаем его. Если же получаем ошибку то вызываем какой то обработчик ошибок а затем выбрасываем ошибку<br>В дальнейшем этот api уже можно использовать где то дальше, например в качестве переданного аргумента для middleware<pre>
const api = createAPI();
const store = configureStore({
  reducer,
  middleware: (getDefaultMiddleware) => {
    getDefaultMiddleware({
      thunk: {
        extraArgument: api
      }
    }),
  }
});</pre>`
    ],
    [
      'Redux Thunk',
      `Middleware который позволяет производить любые действия в том числе асинхронные запросы до выполнения reducer. Также имеет доступ к глобальному состоянию и может его обновлять<pre>
const api = async (id) => {
  const resp = await fetch('url/' + id);
  const data = await resp.json();
  return data.title;
}</pre>Опишем для примера какой то api получения данных <pre>
const setTitleAction = async (dispatch, store, api) => {
  const id = store.getState().id;
  const title = await api(id);
  dispatch(SOME(title));
}</pre>Создание action для thunk. Сначала получаем данные из состояния, затем асинхронный запрос через полученный api и в конце вызываем dispatch с каким то action передав туда полученные данные<pre>
const checkAuthAction = createAsyncThunk&lt;void, undefined, {
  dispatch: AppDispatch, state: State, extra: AxiosInstance
}&gt;(
  'checkAuth',
  async (_arg, {dispatch, extra: api}) => {
    await api.get('url');
  }
);
</pre>Создание action с через RTK для Thunk. Конструктор принимает в качестве 1 аргумента строковое значение action, а во 2 callback где 1 аргумент в данном примере заглушка т.к. мы не передаем никаких данных, а 2 аргумент объект где указываем dispatch и api в поле extra. В теле ф-ции делаем запрос через наш api указав метод get. По скольку конструктор ничего не возвращает то в Typescript 1 тип void. По скольку мы ничего не передаем то 2 тип undefined. Далее указываем типизацию для переданного объекта<pre>
const postComment = createAsyncThunk&lt;Comments, PostComment, {
  dispatch: AppDispatch, state: State, extra: AxiosInstance 
}&gt;(
  'postComment',
  async ({comment, id}, {dispatch, extra: api}) => {
    const {data} = await api.post&lt;Comments&gt;('url/' + id, {comment});
    return data;
  }
);</pre>Action для отправки данных на сервер. api.post возвращает нам объект поэтому мы сразу деструктуризируем его извлекая свойство из data и затем возвращаем полученный результат. В типизации сначала указываем Comments т.к. возвращаем результат в виде обновленного списка комментариев. Затем указываем PostComment это тип объекта для отправки данных.`
    ],
    [
      'MiddleWare',
      `Это ф-ция которая будет выполнена после dispatch() но до обработки reducer. Другими словами позволяет выполнить какую то логику после вызова action но до его выполнения<pre>
const some = (store) => (next) => (action) => {
  console.log('action = ' + action.type);
  console.log('Current state = ' + store.getState());
  const result = next(action);
  console.log('New state = ' + store.getState());
  return result; 
}
const some2 = (store) => (next) => (action) => {
  ...
  next(action); 
}</pre>2 вида собственных middleware. В 1 показано как можно взаимодействовать с измененным состоянием, главное в конце вернуть полученный result. Во 2 мы просто после необходимой нам логике вызываем диспатч с переданным action<pre>
const applyMiddleware = Redux.applyMiddleware;
const store = createStore(reducer, initState, applyMiddleware(some));</pre>Передача MW в store. Сначала инициализируем с помощью оболочки из Redux а затем передаем в качестве 3 параметра в конструктор где параметром оболочки будет наша созданная middleware<pre>
const store = configureStore({
  reducer,
  middleware: [some, some2]
});
const store2 = configureStore({
  reducer,
  middleware: (getDefaultMiddleware) => 
    getDefaultMiddleware({
      thunk: {
        extraArgument: 'some data or function'
      }
    }).concat(some),
});</pre>Передача MW в store через RTK. В 1 случае мы просто передаем все наши созданные MW в свойство middleware в виде массива. Во 2 случае мы сначала описываем callback для использования встроенных MW из Redux(в данном случае thunk) где свойство extraArguments получает какой то api или ц-цию.Сам callback вернет массив, а затем присоединяем к нему свои MW`
    ],
    [
      'Глобальное состояние (самописный для общего представления)',
      `<pre>
const createStore = (reducer, initState) => {
  return {
    _state: initState,
    dispatch(action) {
      this._state = reducer(this._state, action);
    },
    getState() {
      return this._state;
    }
  };
};</pre>Примерно так выглядит создание хранилища store. Вернет объект с установленным начальным значением, методом getState() который будет возвращать текущее значение и методом dispatch() который будет изменять текущее значение с помощью переданного в него action<pre>
const myReducer = (state, action) => {
  switch(action.type) {
    case 'add':
      return state + 1;
    case 'dec':
      return state - 1;
    case 'some':
      return state + action.payload;
    default: return state;
  }
}</pre>Так выглядит reducer. Он нужен чтобы изменять состояние. Основываясь на полученном action.type производит какие то действия. Также action может содержать свойство payload которое будет содержать переданные данные.<pre>
const add = () => {type: 'add'};
const dec = () => {type: 'dec'};
const some = (n) => {type: 'some', payload: n};</pre>Так выглядят action. По сути это ф-ции которые возвращают объект с обязательным полем type и дополнительным payload если передан какой то аргумент<pre>
const store = createStore(myReducer, 0);
btn1.addEventListener('click', () => {
  store.dispatch(add);
});
btn2.addEventListener('click', () => {
  store.dispatch(some(4));
});</pre>Инициализация store и использование метода dispatch()`
    ],
    [
      'Глобальное состояние (функциональный компонент)',
      `<b>index.js</b><pre>
&lt;Provider store={store}&gt;
  &lt;App /&gt;
&lt;/Provider&gt;</pre>Чтобы использовать глобальное состояние во всем приложении делают обертку для главного компонента через Provider указывая ранее созданный store<br><b>action.js</b><pre>
const INC = () => {type: 'INC'};
const ADD_SOME = (value) => {type: 'ADD_SOME', payload: value};</pre>Создание action с помощью которых будем указывать reducer как изменять состояние<br><b>reducer.js</b><pre>
const reducer = (state, action) => {
  switch(action.type) {
    case 'INC':
      return state + 1;
    case 'ADD_SOME':
      return state + action.payload;
    default: return state;
  }
}</pre>Reducer нужен для того чтобы изменять состояние основываясь на полученных action.<br><b>store.js</b><pre>
const store = (initState, reducer) => ({
  _state: initState,
  getState() {
    return this._state;
  },
  dispatch(action) {
    this._state = reducer(this._state, action);
  }
})</pre>Создание store. Принимает исходное состояние а также reducer который и будет изменять его<pre>
function SomeComp({propName, propNameForDispatch}) {
  return (
    &lt;button type="button" onClick={propNameForDispatch}&gt;{propName}&lt;/button&gt;
  );
}
const mapStateToProps = (state) => ({
  propName: state.someValue;
});
const mapDispatchToProps = (dispatch) => ({
  propNameForDispatch: () => dispatch(someAction())
});

export default connect(mapStateToProps, mapDispatchToProps)(SomeComp);</pre>Чтобы связать redux с компонентом сначала создаем ф-цию которая вернет объект, где именем поля будет пропс а значением любое значение из store. Затем создаем ф-цию которая вернет объект где также именем будет пропс а значением ф-ция dispatch с нужным action. После всего с помощью connect связываем эти ф-ции с нашим компонентом и в дальнейшем можем обращаться к данным store или диспатчить в него что то с помощью переданных в props свойств, благодаря этому в случае если store изменится компонент перерисуется т.к. значения из store передаются в props<pre>
function SomeComp() {
  const dispatch = useDispatch();
  const someValue = useSelector((state) => state.value); 

  return (
    &lt;button type="button" onClick={dispatch(someAction())}&gt;{someValue}&lt;/button&gt;
  );
}</pre>В новых версиях достаточно использовать хуки. useSelector является аналогом mapStateToProps и позволяет получать любые данные из store, а также неявно подписывается на изменения состояния. useDispatch это аналог mapDispatchToProps`
    ],
    [
      'Глобальное состояние (RTK)',
      `<b>store.js</b><pre>
const store = configureStore({
  reducer,
  preloadedState: 0,
  devTools: true
});</pre>Создание store с помощью RTK. Принимает объект с настройками где сначала указывается reducer, затем исходное состояние. DevTools указывает можно ли приложению взаимодействовать с браузерным расширением(по умолчанию true)<br><b>action.js</b><pre>
const ACTION = {
  INC: 'INC',
  ADD_SOME: 'ADD_SOME'
};
const inc = createAction(ACTION.INC);
const addSome = createAction(ACTION.ADD_SOME, (value) => ({payload: value}));</pre>Описание action в RTK. Сначала создаем объект для удобства и чтобы избежать ошибок при передаче action(паттерн action creator). Затем создаем сами action передав строковое значение в 1 аргументе. Т.к. в RTK созданные action имеют перезаписанный метод toString() то они возвращают строку action.type. Чтобы передать дополнительные параметры в качестве 2 аргумента создаем callback который получает наш параметр и возвращает объект со свойством payload.<br><b>reducer.js</b><pre>
const reducer = createReducer(initState, (builder) => {
  builder
    .addCase(ACTION.INC, (state) => {
      state = state + 1;
    })
    .addCase(ACTION.ADD_SOME, (state, action) => {
      state = state + action.payload;
    });
});</pre>Создаем reducer с помощью RTK. Получает начальное состояние через 1 аргумент. Чтобы добавить какое то действие достаточно дописать addCase(), в котором в 1 аргумент передается тип action а во 2 callback который получает обязательный state и action если были переданны какие то данные. Внутри callback описывается логика изменения состояния. Благодаря библиотеке immer мы можем сразу указывать какое свойство объекта(если state объект) необходимо изменить(например: state.id = action.payload). Сама библиотека позволяет подобныйм образом изменять иммутабельный объект<pre>
const initStore = {
  count: 0,
  someData: []
};
const reducer = createReducer(initStore, (builder) => {
  builder
    .addCase(ACTION.INC, (state) => {
      state.count += 1;
    })
    .addCase(ACTION.ADD_DATA, (state, action) => {
      state.data.push(action.payload);
    });
});</pre>С помощью immer можно также спокойно добавлять что то в массив в объекте initStore и библиотека сама все правильно обработает`
    ],
    [
      'Жизненные циклы в функциональном компоненте',
      `<pre>
useEffect(() => {
  ...(1)...
  return () => {
    ...(2)...
  }
}, [x]);</pre>Аналог жизненного цикла componentDidUpdate в главном блоке кода и componentWillUnmount в виде блока кода в return, где :<br>1) какая то логика при изменении<br>2) какая то логика в return которая выполнится если компонент будет уничтожен<br>3) после callback ф-ции передается массив зависимостей в котором можно либо указать какие то переменные которые послужат триггером для запуска useEffect либо оставить массив пустым и тогда useEffect сработает 1 раз как componentDidMount но только после отрисовки компонента. Компонент может содержать несколько эффектов и они будут выполнены в том порядке в котором были записаны<pre>
useLayoutEffect(() => {
  ...
});</pre>Этот хук является аналогом componentDidMount и сработает до отрисовки компонента`
    ],
    [
      'useEffect()',
      `Хук который в первую очередь служит методом жизненных циклов компонента. Также служит для того чтобы изолировать побочные эффекты от логики компонента. Что входит в эти эффекты:<br>
      1) Получение данных<br>
      2) Работа с таймерами<br>
      3) Прямое изменение DOM<br>
      4) Изменение размеров элемента<br>
      5) Работа с локальных хранилищем<br>
      6) Подписка на услуги<br>
      В общем это логика которую надо изолировать от рендеринга`
    ],
    [
      'flux архитектура',
      `Подход когда глобальное состояние выносится отдельно от логики компонентов`
    ],
    [
      'defaultProps',
      `<pre>
function SomeComp(props) {
  return(
    &lt;div&gt;{ props.name }&lt;/div&gt;
  );
}

SomeComp.defaultProps = {
  name: 'Guest'
}</pre>Свойство позволяет задать пропсы по умолчанию`
    ],
    [
      'Использование styled библиотеки',
      `<pre>
const Header = styled.h1\`
  display: flex;
  span {
    font-size: 20px;
    color: \${props => props.colored ? 'red' : 'black'}
  }
\`
const AppHeader = () => {
  return (
    &lt;Header colored&gt;
      &lt;span&gt;Some text&lt;/span&gt;
    &lt;Header /&gt;
  ) 
}</pre>Эта библиотека позволяет создавать элементы указав их как свойство объекта styled и сразу же описать для него стили. Также в стилях через props можно указать динамические параметры<hr><b>return (&lt;Header as='a' /&gt;)</b> - позволяет преобразовывать тэг в другой при отрисовке<hr><b>const StyledHead = styled(Header)\`background-color: red;\`</b> - позволяет создавать новые элементы на основе уже созданных и тут же добавлять новые стили`
    ],
    [
      'Хуки',
      `Это функции которые позволяют использовать в функциональных компонентах жизненные циклы, состояние и т.д.<hr>
      Основные правила хуков:<br>
      1) Хуки не используются в циклах или условиях потому что React полагается на порядок вызова хуков и если порядок нарушить будут ошибки<br>
      2) Использовать хуки можно только в компонентах на высшем уровне а не внутри каких то побочных ф-ций по тем же причинам`
    ],[
      'Паттерны',
      `<pre>
function App() {
  return (
    &lt;SomeComp&gt;
      &lt;h1&gt;Some child &lt;/h1&gt;
    &lt;/SomeComp&gt;
  ); 
}

function SomeComp({render}) {
  return (
    &lt;div&gt;
    { children }
    &lt;div&gt;
  ); 
}</pre>Паттерн использования служебного пропса children<pre>
function App() {
  return (
    &lt;SomeComp render={(trigger) => {
      return trigger
        ? &lt;p&gt;Hello&lt;/p&gt;
        : &lt;p&gt;Goodbye&lt;/p&gt;
    }} /&gt;
  ); 
}

function SomeComp({children}) {
  return (
    &lt;div&gt;
    { render(false) }
    &lt;div&gt;
  ); 
}</pre>Паттерн render-props. Позволяет передать в пропс ф-цию для отрисовки каких то элементов<pre>
function SomeComp({someTrigger}) {
  return (
    &lt;div&gt;
    { someTrigger && &lt;p&gt;Hello world&lt;/p&gt; }
    &lt;div&gt;
  ); 
}</pre>Паттерн условный рендеринг позволяет использовать условие в более легкой форме <pre>
function Product({class, product}) {
  return (
    &lt;article className={class}&gt;
      ...
    &lt;/article&gt;
  );
}

function ProductNew({class = '', ...otherProps}) {
  return (
    &lt;Product className={'product--new ' + class} {...otherProps} /&gt;
  );
}

function ProductList({products}) {
  function getType(type, product) {
    switch(type) {
      case 'new':
        return &lt;ProductNew product={product} /&gt;
      default:
        return &lt;Product product={product} /&gt;
    }
  }

  return (
    &lt;ul&gt;
      {
        products.map((prod) => (
          &lt;li key={prod.id}&gt;
            { getType(prod.type, product) }
          &lt;/li&gt;
        ))
      }
    &lt;ul&gt;
  );
}</pre>Паттерн proxy-component. Принцип - сделать обертку для компонента добавив что то новое а потом в родительском компоненте применив паттерн container, основываясь на каком то выборе отрендерить 1 из компонентов. Т.к. в JSX нельзя использовать условия то можно вынести его в отдельную ф-цию а потом в разметке просто ее вызвать`
    ],
    [
      'Хуки Собственные',
      `Бывает случается так что в разных компонентах присутствует одинаковая логика. Это может быть взаимодействие с API или с другими хуками или что то подобное. Чтобы соблюдать принцип DRY эту логику было бы неплохо вынести отдельно. Можно сделать HOC и обернуть необходимые компоненты в него, а можно создать свой хук. По сути это просто ф-ция в которой может быть любая логика которая используется в нескольких компонентах. Внутри своего хука можно использовать уже встроенные хуки`
    ],
    [
      'default value',
      `<b>&lt;input type="text" defaultValue={props.some} /&gt;</b> - этот пропс позволяет передать значение по умолчанию тем самым не заблокировав элемент для ввода`
    ],
    [
      'Состояние компонента',
      `По сути это объект в котором хранятся какие то данные. Если данные изменяются то компонент перерисовывается. Сам объект иммутабельный поэтому для его изменения вызывается специальный метод.<pre>
class Some extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 4
    }
    changeState = (arg) => {
      this.setState((state, arg) => ({value: state.value + arg}));
    }
  } 
}</pre>Создание состояние в классовом компоненте а также создание ф-ции для изменения состояния(вместо return можно просто обернуть весь блок кода {} в ())<pre>
const FuncComponent = () => {
  const [data, setData] = useState([{}]);
  function changeState(prop) {
    setData((data, prop) => {
      return [...data, {prop}];
    });
  } 
}</pre>Создание состояни в функциональном компоненте с помощью хука useState. Сначала с помощью деструктуризации создается переменная data(где хранится состояние) а также ф-ция для изменения, а в сам хук передается исходное значение состояния([{}]). По скольку состояние иммутабельно в ф-ции изменения state передается новый объект в виде объединения старого state и нового свойства<hr>
Если так случилось что у нас есть компонент с локальным состоянием и нам надо как то синхронизировать его с другим компонентом, возможно лучшее решение будет вынести состояние наверх к родительскому компоненту, чтобы был однонаправленный поток данных`
    ],
    [
      'Классовый компонент',
      `<pre>
const Some extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    const {someProp} = this.props;
    return (
      &lt;p&gt;{someProp}&lt;/p&gt;
    )
  }
}</pre>Создание классового компонента. Наследует Component от библиотеки React.`
    ],
    [
      'Создание начальной точки приложения',
      `<pre>
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);</pre>Сначала создается начальная точка приложения в блоке с ID root, а затем в ней отрисовывается главный компонент.`
    ]
  ],
  Sass: [
    [
      `вложенность тегов`,
      `обычная вложенность
      <pre>
div
  p</pre>
      <hr>
      использование контекста в вложенности. Контекст позволяет не писать заного название класса (.some_class-modify).
      <pre>
.some_class
  color: red
  &-modify
    color: black
      </pre>`
    ],
    [
      `$variable: *`,
      `создание переменной. Позволяет поместить в нее какое то значение для дальнейшего использования.`
    ],
    [
      `@import *`,
      `импортирование в sass, где * имя файла ("test.scss")`
    ],
    [
      `@mixin`,
      `позволяет создать набор свойств для последующего применения
      <pre>
@mixin block
  color: red
  padding: 0
.some-class
  @include block</pre>`
    ]
  ],
  Logic: [
    [
      `Различные задачи на логику`,
      `<pre>
a
+
+
b</pre><br>Компилятор JS попытается увеличить b т.к. посчитает a законченным выражением.<hr><b>[] + []</b> - выведет пустую строку, т.к. в первую очередь идет проверка на число а затем на строку и по скольку массив имеет метод toString() то они преобразуются в строку<hr><b>[] + {}</b> - [object Object] потому что объект не может быть представлен в виде строки поэтому вернется описание объекта + пустая строка<hr><b>{} + []</b> - 0 потому что сначала {} будет интерпритирован как пустой блок кода === ничему, а затем будет преобразование пустой строки в число(+n)<hr><b>{} + {}</b> - 2 варианта(все зависит от движка браузера):<br>1) "[object Object][object Object]" как если бы происходило сложение строк<br>2) NaN - потому что сначала идет пустой блок кода а затем унарное преобразование объекта в число<hr><b>Array(3).join('text' - 1);</b> => 'NaNNaN' - потому что сначала создается массив с 3 элементами и затем преобразуется в строку с помощью разделителя 'text' - 1, который не сможет произвести вычитание и вернет NaN<hr><b>'foo' + + 'foo'</b> => 'fooNaN' потому что идет сложение строки с преобразованием строки в число<hr><b>'5' + - '2'</b> => '5-2' потому что идет сложение строки с преобразованием строки в отрицательное число. Если операторов сложения и вычитание будет много то сначала интерпритатор читает запись справа налево пытаясь произвести операции с правой частью выражения<hr><pre>
const x = 3;
'5' + x - x</pre><br> - 50 т.к. сначала идет сложение строк а потом из полученной строки вычитают 3 тем самым преобразуя строку в число<hr><b>0 >= null</b> => true потому что хоть и нельзя сравнивать с null, но тут логика следующая - <br>!(0 < null) => !(false) => true<hr><b>'\\t \\n' - 2</b> => -2 потому что в преобразовании пробельные символы игнорируются и на выходе получается пустая строка которая затем преобразуется в 0<hr><b>'яб' > 'ан'</b> => true потому что строковое сравнение происходит по символьно и если код символа больше (он находится дальше) то он будет весомее<hr>[] + false - null + true => NaN потому что из строки 'false' нельзя вычесть null<hr><pre>
let y = 1;
let x = y = 2;
alert(x);</pre><br> => 2 потому что в последовательном присваивании читается справа налево<hr><b>console.log(2 && 1 && null && 0 && false);</b> => null потому что null будет являться 1 false<hr><b>!!(a && b) === (a && b)</b> => false потому что в левой части идет преобразование в bool а в правой вернется 1 из значений<hr><b>console.log(null || 2 && 3 || 4);</b> => 3 потому что сначала будет вычисленно выражение && потому что у него приоритет выше и в итоге мы получим - null || 3 || 4<hr><b>alert(alert(1) || 2 || alert(3));</b> => 1 потом 2 потому что сначала сработает алерт из условия но т.к. сам метод вернет undefined то 1 true в условии будет 2<hr>`
    ],
    [
      `Функция проверки палиндрома`,
      `Следующая функция проверяет является ли слово палиндромом(словом которое читается одинаково со всех сторон)<pre>
function check(str) {
  return str === str.split('').reverse().join('');
}</pre>`
    ],
    [
      `Функция получения самого короткого слова в строке`,
      `Следующая функция находит самое короткое слово в строке<pre>
const check = (str) => str.split(' ').sort((a, b) => a.length - b.length)[0];</pre>`
    ],
    [
      `Функция создания инициалов из полученной строки`,
      `Следующая функция создает строку с инициалами из полученной строки<pre>
const initial = (str) => str.split(' ').map(word => word[0].toUpperCase() + '.').join('');</pre>`
    ],
    [
      `Функция суммирования всех цифр числа`,
      `Следующая функция возвращает сумму всех цифр переданного числа<pre>
const sum = (num) => Math.abs(num).toString().split('').reduce((s, n) => s += +n, 0);</pre>`
    ],
    [
      `Функция поиска min и max в массиве чисел`,
      `Следующая функция возвращает максимальное и минимальное число в массиве<pre>
const minMax = (ar) => [Math.min(...ar), Math.max(...ar)];</pre>`
    ],
    [
      `Функция удаления свойста из объекта`,
      `Следующая функция удаляет переданное свойство в 1 аргументе из объекта во 2 аргументе<pre>
const deleteValue = (val, obj) => {
  const {[val]: del, ...result} = obj;
  return result;
};</pre>`
    ],
    [
      `Функция фильтрации массива (filter)`,
      `Следующая функция возвращает новый массив на основе массива из 1 аргумента отфильтрованного по условию callback переданного во 2 аргументе<pre>
const myFilter = (ar, cb) => {
  const result = [];
  ar.forEach((it) => {
    if (it && cb(it)) result.push(it);
  });
  return result;
}</pre>`
    ],
    [
      `Функция преобразования элементов массива (map)`,
      `Следующая функция возвращает новый массив на основе массива из 1 аргумента при этом изменяя элементы массива на основе переданной callback из 2 аргумента<pre>
const myMap = (ar, cb) => {
  const result = [];
  ar.forEach(it => {
    result.push(cb(it));
  });
  return result;
}</pre>`
    ],
    [
      `Функция схлопывания элементов массива (reduce)`,
      `Следующая функция возвращает значение полученное из преобразования элементов массива переданного 1 аргументом на основе условия переданного в callback 2 аргументом а также принимает в качестве 3 аргумента начальное значение<pre>
const myReduce = (ar, cb, start = null) => {
  let result = start;
    ar.forEach(it => {
      if (result) {
        result = cb(result, it)
      } else {
        result = it;
      }
  })
  return result;
}</pre>`
    ],
    [
      `Функция изменения имени свойста объекта`,
      `Следующая функция изменяет имя переданного свойства в 1 аргументе на имя переданное во 2 аргументе из объекта в 3 аргументе<pre>
const renameVal = (oldV, newV, obj) => {
  const {[oldV]: del, ...result} = obj;
  return {[newV]: del, ...result}
};</pre>`
    ],
    [
      `Функция добавления свойства в объект`,
      `Следующая функция добавляет переданное свойство в 1 аргументе из объекта во 2 аргументе<pre>
const addValue = ({...val}, obj) => {...obj, ...val}</pre>`
    ]
  ],
  TypeScript: [
    [
      `Типизация параметров ф-ции`,
      `<b>function some (obj: {width: number, name: string}) { }</b><br>Типизация параметра в качестве объекта<hr><b>function some (callback: (n: number) => void) {}</b><br>Типизация параметра в качестве переданной callback<hr><b>function some (n: number): string {}</b>Типизация возвращаемого значения ф-ции. Если ф-ции ничего не возвращает то будет void<hr><pre>
function some (): never {
  throw new Error('error'); 
}</pre>Для ф-ций тип never используется если они выбрасывают ошибку или выполняются бесконечно(если отметить типом never переменную или свойство объекта то в дальнейшем указать какое либо значение в нее будет невозможно)<hr><b>function some (...args: number[]): void {}</b>Типизация rest параметров ф-ции<hr><b>function some (a: string, b?: number): void {}</b>Типизация опционального параметра. В этом случае необходимо проверять этот параметр в теле ф-ции перед его использованием`
    ],
    [
      `Типизация массива`,
      `<b>const ar: string[] = ['a', 'b'];</b> - типизация массива со строками`
    ],
    [
      `Тип never`,
      `<pre>
function someF(): never {
  throw new Error('ERROR'); 
}</pre>Тип используется в функциях если она выбрасывает ошибку<pre>
type Obj = {
  id?: never;
  [key: string]: boolean; 
}</pre>В объектах тип never используется для исключения какого то свойста. Т.е. объект не может иметь свойство id`
    ],
    [
      `Типизация после преобразования формата`,
      `<pre>
const somethingJson = '{ "title": "Hello TypeScript" }';
cons obj = JSON.parse(somethingJson);</pre>Тут объект obj получит тип any потому что TS не может определить что за тип вернет ф-ция<pre>
const a = '{ "value": "text" }';
type A = { value: string }
const b: A = JSON.parse(a);</pre>Теперь все работает как надо и объект получил нужный тип`
    ],
    [
      `Автоматическая типизация`,
      `<b>const a = 'text';</b> Тут TS автоматически присвоил тип string потому что переменная была инициализированна при объявлении<br>
      <pre>
let b;
b = 'text';</pre> А тут TS присвоит тип any потому что инициализация была позже чем объявление и при объявлении ей был присвоен тип any`
    ],
    [
      `Типизация объекта с динамическими полями`,
      `<pre>
let permission: {
  [propertyName: string]: boolean | number,
};</pre>Тут с помощью специальной сигнатуры указали что ключ объекта строка а его значение может быть либо булево либо число`
    ],
    [
      `Указание переменной свойста только для чтения`,
      `<pre>
let guitarPlayer: {
  readonly firstname: string,
  readonly lastname: string,
  guitarCount: number,
};</pre>Здесь двум полям объектауказали что они только для чтения и дальнейшие попытки изменить их приведут к ошибке TS<br>
<b>const arr: readonly string[] = ['text', 'text2'];</b> а тут указали целый массив который нельзя изменить`
    ],
    [
      `Объединение типов`,
      `<b>const a: string | number = 'text';</b>Позволяет указывать несколько возможных типов для переменных, но в таком случае следует производить некоторые проверки перед использованием таких переменных`
    ],
    [
      `Дженерики`,
      `Дженерик - это обобщенный тип который нужен для более гибкого создания типов. По сути это абстрактный каркас позволяющий указывать типы данных на этапе использования<pre>
type SomeType&lt;T&gt; {
  id: number;
  any: T; 
}
const variable: SomeType&lt;string&gt; = {
  id: 4,
  any: 'hello' 
}</pre>Позволяет передать тип на этапе использования подобно аргументу ф-ции<pre>
type SomeType = {
  id: number;
  name: string; 
}
type ObjKeys&lt;T&gt; = keyof T;
type SomeTypeKeys = ObjKeys&lt;SomeType&gt;\;
const key: SomeTypeKeys = 'name';</pre>Создает обобщенный тип на основе ключей объекта. По сути берет ключи объекта и превращает их в строковый или числовой литерал и обобщает через |<hr>
<b>type SomeType&lt;T = string&gt; = { ... };</b> - Создание дженерика с значением по умолчанию<pre>
function someFunc&lt;T&gt; (arg: T): T {
  return arg; 
}
someFunc&lt;number&gt;(4);</pre>Дженерик в ф-ции позволяет более гибко использовать ф-цию указывая тип на этапе использования<hr>
<b>const someFunc = &lt;T&gt;(arg: T): T => { ... }</b> - дженерик в стрелочной ф-ции<pre>
type SomeType&lt;T, U&gt; = {
  id: T;
  name: U; 
}
const x: SomeType&lt;number, string&gt; = {
  id: 4,
  name: 'Bob' 
}</pre>В дженериках можно использовать несколько условных типов<pre>
type SomeType = {
  length: number;
}
function someFunc&lt;T extends SomeType&gt;(arg: T): number {
  return arg.length;
}</pre>Ограничения дженерика позволяют указывать некие условия. В данном случае мы указываем что тип аргумента должен содержать свойство length с числовым значением`
    ],
    [
      `Создание типа на основе другого`,
      `<pre>
type a = {
  id: number;
  name: string;
  trigger: boolean;
}
type b = Omit&lt;a, 'id'&gt;\;</pre>Создает новый тип на основе другого при этом позволяет удалять одно или нескольких свойств<br>
<b>type c = Omit&lt;a, 'id' | 'name'&gt;\;</b> - удаляет сразу несколько свойств<hr>
<b>type d = Omit&lt;a, keyof b&gt;\;</b> - новый тип на основе типа a но при этом исключает всей свойства что есть в типе b<hr>
<b>type e = Pick&lt;a, 'id' | 'trigger'&gt;\;</b> - новый тип на основе a при этом будут записаны только указанные свойства`
    ],
    [
      `Типизация смешанного массива`,
      `<b>const ar: (string | number)[] = [123, 'text, 'another', 44];</b> - описание типа для смешанного массива`
    ],
    [
      `Интерфейсы`,
      `<pre>
interface IDev {
  num: number;
  funct: () => void; 
}</pre>Создание простого интерфейса. Интерфейс во многом похож на type но имеет ряд отличий. Хорошо применяется в ООП разработке классов и библиотек<hr><b>class SomeClass implements IDev { }</b> Создание класса наследуемого интерфейс<pre>
interface A {
  age: number; 
}
interface B {
  eat: () => void; 
}
interface C extends A, B {
  name: string;
}
const x: C = {
  age: 15,
  name: 'Bob',
  eat () {} 
}</pre>Использование интерфейса унаследованного от других. Наследование нескольких интерфейсов возможно если указать их через ,.<pre>
interface A {
  age: number; 
}
interface A {
  name: string; 
}
const x: A = {
  age: 3,
  name: 'Bob' 
}</pre>Если в 1 блоке кода создать 2 интерфейса с одинаковым именем они сольются в 1. В целом интерфейсы похожи на перечисления но их можно сливать вместе и наследовать<br>При пересечении(&) или объединении(|) интерфейсов на выходе получим enum<pre>
class A {
  jump () {} 
}
interface B extends A {
  walk: () => void; 
}
class D extends B {
  jump () {}
  walk () {}
  some() {} 
}</pre>Интерфейс также может наследовать из класса<pre>
interface Ix = [string, number]; // - так сделать не получится
interface Imy {
  name: string;
  someAr: [string, number]; 
}</pre>Интерфейс не может определять кортеж но можно определять кортеж внутри него`
    ],
    [
      `Кортеж`,
      `<b>const a: [string, number] = [4, 'text'];</b>Объявление кортежа. Кортеж по сути это массив с ограничениями по длине и содержимому где нельзя удалять/добавлять/изменять тип содержимого а также менять порядок элементов. Также можно запретить изменять значения кортежа указав readonly.<hr>
      <b>const tuple = ['name', 15] as const;</b> - это упрощенная форма записи неизменяемого кортежа<hr> По сути это замороженный массив - <b>const tuples = (...args) => Object.freeze(args);</b>. При последующей работе с ним можно изменять его данные на данные того же типа. Также можно добавлять новые элементы через push и они будут видны при полном переборе массива, но взаимодействовать с новыми элементами будет нельзя. Для избежания такого поведения следует добавить свойство readonly - <b>const a = [4, 'text'] as const;</b><br><b>const a: [number, string, [...boolean[]] = [4, 'text', true, false];</b> - Спред оператор позволяет делать кортеж любой длины и добавлять ему сколько угодно булевых значений. Но на самом деле в таком случае мы можем добавлять любые типы и не получим ошибки!`
    ],
    [
      `Перечисления`,
      `<pre>
enum Dir {
  LEFT: 'left',
  RIGHT: 'right' 
}</pre>Перечисление это паттерн который по сути является объектом для указания каких то жестко фиксированных параметров чтобы избежать ошибок при подставлении их напрямую(в виде строки например). Свойста enum именуются большими буквами а также желательно чтобы их содержимое было 1 типом.<pre>
const Dir = {
  LEFT: 'left',
  RIGHT: 0 
}</pre>Для перечислений с разными типами лучше использовать обычный объект<pre>
var dir;
(function (dir) {
  dir["LEFT"] = 'left';
  ...
})(dir || (dir = {}));</pre>При компиляции enum превращается в ф-цию в теле которой собирается объект. Поэтому в значение свойств перечислений можно также задавать ф-цию но тогда они должны что то возвращать НО только если enum не является const. В случае если const enum то компилятор будет просто возвращать значения свойств поэтому в них нельзя использовать результат вычисления ф-ций. Но если константа вообще ни где не используется то в компиляторе ее не будет. Главным преимуществом константных перечислений является то что они менее ресурсо затратные потому что при компиляции не создается и не вызывается ф-ция<pre>
const Direction = {
  Left: 1,
  Right: 2,
  Up: 3,
  Down: 4
} as const;</pre>В актуальных версиях TS можно создавать перечисления с помощью обычных объектов при этом в конце указав их как const<pre>
const Direction = {
  Left: 1,
  Right: 2,
  Up: 3,
  Down: 4
} as const;

type DirectionEnum = typeof Direction[keyof typeof Direction];</pre>Типизация ключей перечисления если перечисление создано как объект<pre>
type Direction = {
  LEFT: 'left',
  RIGHT: 'right' 
}
type X = keyof Direction;</pre>Типизация ключей перечисления если enum<hr>Если перечислениям не задано значение то оно автоматически становится числом. Компилятор устанавливает их по порядку начиная с 0<hr>
В значение перечислений можно передавать результат выполнения ф-ций, но тогда результатом ф-ции должно быть только число`
    ],
    [
      `Пересечение типов`,
      `<pre>
type First = {
  a: number;
}
type Second = {
  b: string; 
}
type All = First & Second;
const some: All = {
  a: 4,
  b: 'hello' 
}</pre>Пересечение типов позволяет объединять типы в 1. Т.е. результат пересечения должен содержать все поля переданных типов (как объединение объектов)`
    ],
    [
      `Создание псевдонимов типа`,
      `<pre>
type MyRect = {
  width: number;
  height: number; 
  name: string;
  trigger: true;
}</pre>Создание псевдонима для объекта<hr><pre>
type Callback = (message: string) => void;</pre>Создание псевдонима для ф-ции`
    ]
  ],
  Unit_Tests: [
    [
      `Создание моковых данных`,
      `<pre>
const fakeSomeData = () => ({
  name: name.title(),
  age: number.random(),
  keywords: Array.from(3).fill(null).map(item => {
    return words.word();
  })
});</pre>Функция генератор моковых данных по аналогу каких то данных, возвращает объект. Для получения значений полей используется библиотека faker`
    ],
    [
      `Общий принцип описания тестов`,
      `<pre>
describe('Function: add', () => {
  it('should return 4 when args = 2 and 2', () => {
    const a = 2;
    expect(add(2, 2)).toBe(4);
  });
});</pre>Сначала описывается общее описание в ф-ции describe. Далее внутри для каждой ситуации описывается метод it, где внутри сначала идет описание ф-ции а в теле callback описывается какая то логика. Метод expect принимает проверяемую ф-цию или данные а после вызывается 1 из методов для проверки результатов`
    ],
    [
      `Методы expect()`,
      `<b>.toBe(x)</b> - проверяет что полученный результат равен x<br>
      <b>.toEqual({some: 0, another: 'test'})</b> - сравнивает объекты<br>`
    ],
    [
      `Тест своих middleware`,
      `<pre>
const fakeHistory = {     <sup>1</sup>
  location: {pathname: ''},
  push(path) {
    this.location.pathname = path;
  } 
};
_jest.mock('URL', () => fakeHistory);   <sup>2</sup>

const middlewares = [redirect];     <sup>3</sup>
const mockStore = configureMockStore(middlewares);
const store = mockStore();

describe('middleware - redirect', () => {
  beforeEach(() => {      <sup>4</sup>
    fakeHistory.push('');
  });
  it('should be redirect to /login', () => {
    store.dispatch(redirectToRoute('/login'));
    expect(fakeHistory.location.pathname).toBe('/login);
    expect(store.getActions()).toEqual([redirectToRoute['/login']]);
  });
});
</pre>1)Создаем имитацию browserHistory который не может быть вызван в node.js. По сути просто объект с свойством и методом для его обновления<br>
2)Переключатель используется когда тестовая ф-ция обращается к какой то импортируемой сущности которая не может быть вызвана вместо нее будет вызвана имитация. В 1 аргументе принимает путь импортируемой сущности во 2 callback которая вернет имитацию<br>
3)Создаем моковый store в который передаем массив с middleware и далее создаем экземпляр этого store<br>
4)Ф-ция позволяет перед каждым вызовом it произвести какую то операцию. В нашем случае очистить историю<br>
В самом тесте мы сначала диспатчим action с редиректом передав путь а затем проверяем сначала на то изменилось ли поле нашего fakeHistory и был ли вызван dispatch вообще`
    ],
  ]
};
