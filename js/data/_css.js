const Css = [
  [
    `text-align`,
    `Выравнивает содержимое внутри контейнера по горизонтали(устаревший метод)`
  ],
  [
    `filter`,
    `Свойство позволяет применить к элементу различные графические эффекты (blur, brightness, drop-shadow...)`
  ],
  [
    `object-fit`,
    `Свойство подобно background-size позволяет указать как медиа элемент(img video) будут заполнять область`
  ],
  [
    `Выборка с исключением`,
    `<b>$('x:not(y)')</b> - Выборка элементов х но только тех что не подходят условиям в у. Например - $('a:not(a[href])') - выбрать все элементы a у которых нет атрибута href<br><b>$(x).not(y)</b> - аналогичная запись. Например - $('a').not('a[href]')`
  ],
  [
    `Выборка прямого потомка`,
    `<b>.div > *</b> - позволяет выбрать всех прямых потомков(*) или можно указать более конкретно`
  ],
  [
    `Выборка следующего элемента`,
    `<b>div + p</b> - позволяет выбрать следующий соседний элемент на одном уровне вложенности и с одним родителем`
  ],
  [
    `Выборка всех элементов на этом же уровне вложенности`,
    `<b>div ~ p</b> - позволяет выбрать все элементы на этом же уровне вложенности у которых тот же родитель что и у целевого элемента`
  ],
  [
    `shape-outside`,
    `Свойство позволяет задать элементу не прямоугольную форму, благодаря этому inline элементы обтекают этот элемент по форме. Но такой элемент должен иметь размеры`
  ],
  [
    `perspective: x`,
    `Свойство позволяет указать расстояние между осью Z и пользователем, где х число в ед измерения размеров. Свойство полезно при использовании различных анимаций`
  ],
  [
    `background-blend-mode`,
    `Свойство позволяет указать как фоновое изображение будет взаимодействовать с фоновым цветом`
  ],
  [
    `box-decoration-break`,
    `Свойство позволяет указать как будут отображаться фрагменты элемента при переносе строки<br>
    <img src="./img/box-dec-slice.jpg" /><br>
    <b>slice</b> - в данном случае текст просто переносится без особых оформлений<br>
    <img src="./img/box-dec-clone.jpg" /><br>
    <b>clone</b> - а в этом случае стили для всей строки применяться к каждому фрагменту`
  ],
  [
    `Вендорные префиксы`,
    `Специальная приставка для свойств которые не внедренны в браузер (-moz-opacity)`
  ],
  [
    `Блочная модель элемента`,
    `Правила по которым браузер определяет размеры элемента. Внешний отстут, рамка, внутренний отступ, размер контента.`
  ],
  [
    `Специфичность селекторов`,
    `Это градация приоритета стилей элемента<br>1. inline - 1000<br>2. id - 100<br>3. class/attr/: - 10<br>4. элемент/:: - 1`
  ],
  [
    `Варианты добавления CSS на сайт`,
    `1. Инлайн стили внутри самого тега (style, переопределение такого стиля возможно только с использованием !important)<br>2. Глобальные стили внутри тега head через тег &lt;style&gt;<br>3. Внешний файл стилей через link<br>4. Импорт внутри файла стилей`
  ],
  [
    `Процесс обработки значений в конечное`,
    `1. Сначала идет загрузка значений из CSS и решение конфликтов<br>
    2. Элементам у которых должно быть значение и которые не были описаны в CSS назначаются стандартные значения браузера<br>
    3. Оставшимся элементам присваивается начальное состояние значения(например padding: 0)<br>
    4. Относительные единицы переводятся в px (em, rem)<br>
    5. % переводятся в px<br>
    6. На основе всех полученных значений происходит последний расчет где все не целые значения округляются`
  ],
  [
    `Расчет относительных единиц`,
    `<b>font-size: %</b> - высчитывается от родительского шрифта(в случае html от стандартного шрифта браузера)<br>
    <b>font-size: em</b> - высчитывается от родительского шрифта<br>
    <b>font-size: rem</b> - высчитываетсяо от шрифта в html или от стандартного браузерного(16px)<br>
    <b>width/height: %</b> - высчитываются от ширины родителя<br>
    <b>width/height: em</b> - высчитываются от шрифта текущего элемента`
  ],
  [
    `Порядок парсинга сайта`,
    `1. Загрузка html<br>
    2.1. Парсинг html<br>
    2.2. Загрузка css<br>
    3.1. Построение DOM дерева<br>
    3.2. Парсинг css:<br>
    3.2.1. Разрешение конфликтов<br>
    3.2.2. Высчитывание конечных значений свойств<br>
    4. Построение CSS DOM<br>
    5. Отрисовка дерева<br>
    6. Отрисовка сайта<br>
    7. Вывод результата`
  ],
  [
    `Как наследуются значения в CSS`,
    `Так как у большинства свойств должны быть определены значения то они определяются следующим образом в случае наследования:<br>
    1. Указано ли значение в стилях? Если да то значение берется оттуда<br>
    2. Если нет то проверяется может ли свойство наследоваться. Если да то значение берется из родительского элемента. Если нет то устанавливается стандартное значение браузера или начальное состояние<br>
    (Свойства относящиеся к тексту наследуемые, остальные в основном нет, но стоит проверять)`
  ],
  [
    `Парсинг CSS и разрешение конфликтов`,
    `1. Сначала идет рассмотрение приоритета CSS правил:<br>
    I. Свойства с атрибутом !important<br>
    II. Свойства описанные в CSS<br>
    III. Браузерные стандартные свойства<hr>
    2. Затем если конфликт не разрешен используется специфика селекторов:<br>
    I. inline стили
    II. селектор id<br>
    III. селектор class/pseudo/по атрибуту<br>
    IV. селектор по тэгу<br>
    в итоге получается что то вроде такой записи - x.x.x.x и затем они сравниваются в случае конфликта по очередно каждую цифру слева направо. Как только в 1 из вариантов число оказывается больше чем у других сравнение останавливается и выбирается значение свойства из этого правила.<pre>
button.button {
color: red;
}
div#div .button {
color: black;
}</pre>В данном случае спецификация 1 варианта будет - 0.0.1.1 а 2 - 0.1.1.1 и приоритет будет выше у 2 варианта<hr>
3. Если конфликт остается не разрешен то в приоритете будет то правило что было загруженно последним<br>
Общий селектор * имеет 0 спецификацию`
  ],
  [
    `display: flex`,
    `justify-content: * - выравнивание элементов по горизонтали если направление по оси Х или по вертикали если Y.
    <hr>
    align-item: * - выравнивание по вертикали если направление по Х и по горизонтали если по Y.
    <hr>
    * - <br>
    flex-start - по левой/верхней стороне<br>
    flex-end -  по правой/нижней стороне<br>
    center - по центру<br>
    space-between - создает одинаковые отступы между элементами<br>
    space-around - делает отступы вокруг элементов из свободного пространства(по бокам выходит меньше потому что равны 0.5 от межблочных отступов)<br>
    space-evenly - распределяет свободное пространство для отступов вокруг элементов по ровну<br>
    stretch - растягивает элементы
    <hr>
    flex-direction - направление расположения элементов<br>
    row - справа налево (по default)<br>
    row-reverse - слева направо<br>
    column - сверху вниз<br>
    column-reverse - снизу вверх
    <hr>
    order - задает порядок элементов. По default = 0, 1 - сдвигает вправо, -1 влево.
    <hr>
    align-self - задает положение только для 1 элемента
    <hr>
    flex-wrap - обертка где:<br>
    nowrap - размеры элементов автоматически подгоняются для установки в 1 ряд<br>
    wrap - переносит элементы что не влезли<br>
    wrap-reverse - перенос с реверсом
    <hr>
    flex-flow - объединяет direction и wrap в 1 свойстве (flex-flow: column wrap)
    <hr>
    align-content - распределяет свободное пространство между и вокруг флекс элементов по оси Y`
  ],
  [
    `margin`,
    `Если у 2 элементов имеются отступы направленые друг к другу, то выберется тот что больше. Это называется
    схлопыванием.
    <hr>
    Обычно задается справа налево или сверхну вниз. Связано с тем что принято что блок не может двигать сам
    себя, а его двигает сосед (*-bottom, *-right).
    <hr>
    : 0 auto - выравнивание блока по горизонтали если задана ширина.`
  ],
  [
    `display: table-cell`,
    `Указывает элементу что он является ячейкой таблицы, при этом родительский элемент должен быть display: table. Удобно если нужно выстроить рядом несколько блоков и чтобы они были одной высоты`
  ],
  [
    `Единицы изменения`,
    `em - единица измерения на основе font-size. (1em = font-size). Подходит для позиционирования.
    <hr>
    rem - единица всегда равна 16px
    <hr>
    vh - равна высоте размера экрана
    <hr>
    vw - равна ширине размера экрана + скроллбар`
  ],
  [
    `box-shadow`,
    `задает тень блоку.<br>
    : 0px 4px 4px rgba(0, 0, 0, 0.25) - где 1 отклонение по Х относительно блока, 2 по Y, 3 радиус размытия, 4 цвет.`
  ],
  [
    `clip-path`,
    `Свойство позволяет выделить у элемента видимую часть в виде какой либо фигуры<br>
    <b>clip-path: *function(x)</b> - function определенная функция для отрисовки фигуры а х координаты или размеры в зависимости от ф-ции. Все координаты указываются относительно левого верхнего угла<br>
    <b>circle(50%)</b> - отрисовка круга<br>
    <b>ellipse(x y a b)</b> - овал где х - ширина по х, у - высота по у, a - смещение от левого угла по х, b - смещение от верхнего угла по у<br>
    <b>pollygon(x y, x y, x y, ...)</b> - отрисовка многоугольника где х у координаты углов фигуры. Минимум необходимо 3 точки<br>
    <b>path(x)</b> - отрисовка сложной фигуры где х задается также как path в svg`
  ],
  [
    `transform`,
    `<b>translateY(*px)</b> - сдвигает элемент на * пикселей по вертикали.<br>
    <b>translateX(*px)</b> - сдвигает по горизонтали<br>
    <b>translate(*px, *px)</b> - комбинированная запись где 1 по Х 2 по Y<br>
    <b>rotate(xdeg)</b> - поворачивает элемент на х градусов<br>
    <b>scale(x)</b> - увеличивает элемент в х раз<br>
    <b>skew(xdeg)</b> - создает перекос элемента на х градусов`
  ],
  [
    `transition`,
    `задает скорость анимации и свойство к которому оно применяется<br>
    : 1s all - 1 секунда для всех свойств`
  ],
  [
    `columns`,
    `Короткая запись свойств разбиения текста на колонки:<br>
    <b>columns-count</b> - количество колонок<br>
    <b>columns-gap</b> - отступ между колонками<br>
    <b>columns-rule</b> - стилизация разделительной полосы между колонками`
  ],
  [
    `transform-origin`,
    `Позволяет указать относительно какого места производить трансформацию. По умолчанию center`
  ],
  [
    `object-fit`,
    `указывает для &lt;img&gt; и &lt;video&gt; как контент должен заполнятся относительно высоты и ширины`
  ],
  [
    `white-space`,
    `форматирование текста. По default normal(обрезает пробелы и отступы).<br>
    : pre - оставляет текст в оригинальном форматировании`
  ],
  [
    `padding`,
    `Устанавливает отступы внутри элемента.
    <hr>
    Если у элемента нет соседей сверху и слева, то для того чтобы его пододвинуть родительскому контейнеру
    задается отступ (*-left, *-top).`
  ],
  [
    `z-index`,
    `Позиционирует элемент относительно оси z. По дефолту - 0. Работает только с absolute/relative.`
  ],
  [
    `border-box`,
    `box-sizing - при использовании отступов или border размер элемента не изменяется.`
  ],
  [
    `border-collapse`,
    `Указывает как отображать рамки соседних элементов<br>collapse - рамки будут схлопнуты как если бы это была цельная таблица<br>separate - у каждого элемента будет рамка и между ними будут отступы заданные border-spacing`
  ],
  [
    `@font-face`,
    `Подключение сторонего шрифта:<br>
    font-family: 'имя' - имя шрифта<br>
    src: local('имя') - сначала ищет на локальной машине<br>
    src: url(путь) - если на локальной не найдено то берет с Url.<br>
    font-display: swap - указывает что шрифт грузится асинхронно и пока он не подгружен будет применен стандартный шрифт<br>`
  ],
  [
    `Семантические теги`,
    `предназначены для поисковиков и скринридеров`
  ],
  [
    `БЭМ`,
    `блок + модель + модификатор - позволяет создавать блоки для дальнейшего переиспользования.
    <br>
    блокам не задают отступы
    <br>
    элемент - составная часть блока (class="блок-1__имя-элемента"). Элемент всегда часть блока а не другого элемента.
    <br>
    Модификатор - изменяет состояние элемента (class="блок__элемент-модификатор")`
  ],
  [
    `Шрифты`,
    `с засечками - serif, без засечек sans-serif`
  ],
  [
    `Выборка по тегу с частью значения`,
    `<b>[class^="some-"] {}</b> - такая запись позволяет выбрать все элементы с классом начинающимся с "some-"<br>
    ^ - начинающиеся с указанной строки<br>
    $ - кончающиеся<br>
    * - указанная строка является частью полного значения атрибута`
  ],
  [
    `background-clip`,
    `Свойство позволяет указать поведение фонового изображения<br>
    1. <b>border-box</b> - фон будет отображаться во всей блочной модели элемента<br>
    2. <b>padding-box</b> - фон будет отображаться только в content и paddign зонах<br>
    3. <b>content-box</b> - только в контентной зоне<br>
    4. <b>text</b> - фон будет отображаться только под текстом. Но для этого необходимо следующее<pre>
p {
color: transparent;
background-image: linear-gradient(to right, red, black);
background-clip: text;
}</pre>`
  ],
  [
    `float: left/right;`,
    `Свойство позволяет указать что все последующие элементы будут обтекать текущий элемент. Если указанно значение left то сам элемент прижмется к левой части а все что за ним обтекут его по правой стороне и наоборот. Сам блок становится display: block но по ширине ужимается до контента<br>
    Элемент с этим свойством не влияет на высоту родительского элемента, поэтому он может схлопнуться. Чтобы избежать этого есть 2 варианта:<br>
    1. Добавить следующие св-ва родителю - <pre>
::after {
content: "";
display: table;
clear: both; 
}</pre> Но этот вариант не лучший т.к. добавляет еще 1 элемент в разметку<br>
2. Установить родителю свойство overflow: hidden`
  ],
  [
    `backface-visibility`,
    `Свойство позволяет указать будет ли видна задняя часть элемента к примеру при развороте. В случае visible задняя сторона будет зеркальным отражением, в случае hidden сторона будет скрыта<br>
    Также это свойство помогает избавиться от бага когда при использовании анимации элемент начинает трястись. В таком случае необходимо родительскому элементу анимируемого добавить это свойство в значении hidden`
  ],
  [
    `outline-offset`,
    `Свойство устанавливает отступ между outline и border`
  ],
  [
    `:nth-child(2n)`,
    `Псевдокласс позволяет задать свойста для каждого 2 элемента`
  ],
  [
    `animation-fill-mode: backwards`,
    `При использовании анимации это свойство применяет к элементу свойства начального состояния анимации, тем самым позволяя нормально использовать задержку анимации`
  ],
  [
    `position`,
    `relative - позволяет позиционировать относительно своего места при этом не выбивается из общего потока
    тегов.
    <hr>
    absolute - позиционируется от body если родителю не задан relative. При этом превращает элемент в
    строчный и выбивается из общего потока тегов.
    <hr>
    fixed - фиксирует элемент в заданном месте при прокрутке. Превращает в строчный элемент.
    <hr>
    sticky - когда страница прокручивается до такого элемента он становится fixed.`
  ],
  [
    `background-...`,
    `repeat - Повторять или нет изображение в элементе.
    <hr>
    position - позиция фонового изображения. Указывается словестно или в px, где 1 значение left, 2 top.
    <hr>
    size - contain/cover, где 1 увеличивается пока не упрется в высоту, а 2 заполняет во всю ширину но
    обрезается по высоте.
    <hr>
    attachment - поведение при прокрутке страницы
    <hr>
    background: url(...) .. center/size - сокращенная запись где позиция и размер указываются через /.
    <hr>
    image - позволяет указать фон элемента в виде картинки или линейного градиента либо все вместе<br>
    <b>background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(100, 100, 100, 0.5)), url(../img/a.png);</b> - совмещение градиента и фоновой картинки. Порядок положения фонов такой же как и в очереди определения => ниже тот кто определен в конце.
    <hr>
    linear-gradient(угол, цвет1 %перехода, цвет2 %перехода) - линейный градиент где %перехода обозначает
    место в котором 1 цвет переходит во 2.<br>
    radial-gradient(x, y) - круговой градиент где х начальный цвет от центра и у конечный цвет у края круга`
  ],
  [
    `list-style-type`,
    `Установка маркеров для списков (&lt;ol&gt;, &lt;ul&gt;), где none - отключает маркеры.`
  ],
  [
    `hyphens`,
    `Позволяет указать текстовым элементам как переносить слова:<br>
    <b>auto</b> - бразурер автоматически будет делать перенос если это возможно<br>
    <b>manual</b> - позволяет в ручную указать перенос<br>
    <b>none</b> - значение по умолчанию`
  ],
  [
    `linear-gradiend()`,
    `Ф-ция для установки линейного градиента.<br>linear-gradient(x, #000 25%, #666 25% 50%, #fff 75%) - где<br>--1 цвет имеет конечную точку(там где начинается переход во 2)<br>--2 цвет имеет начальную точку там же где и конечная у 1 цвета и поэтому плавного перехода не будет. А также имеет конечную точку на 50% что означает там начнется переход в 3 цвет<br>--3 цвет поскольку является последним то имеет начальную точку в которой заканчивается последний переход.<br>x - это необязательный параметр указывающий направление градиента. По умолчанию он направлен сверху вниз. Может быть:<br>1) xdeg - указан в углах<br>2) xturn - указан в частях от единицы, где 0.25 = 90deg<br>3) to top left - может быть указан явно а также скомбинирован из нескольких направлений`
  ]
];